import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";

/* eslint-disable camelcase, max-statements */
import unpackGLBBuffers from './unpack-glb-buffers';
import unpackBinaryJson from '../packed-json/unpack-binary-json';
import { TextDecoder, padTo4Bytes, assert } from '@loaders.gl/core';
import { ATTRIBUTE_TYPE_TO_COMPONENTS, ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE, ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY } from '../utils/gltf-type-utils';
var MAGIC_glTF = 0x676c5446; // glTF in Big-Endian ASCII

var GLB_FILE_HEADER_SIZE = 12;
var GLB_CHUNK_HEADER_SIZE = 8;
var GLB_CHUNK_TYPE_JSON = 0x4E4F534A;
var GLB_CHUNK_TYPE_BIN = 0x004E4942;
var LE = true; // Binary GLTF is little endian.

var BE = false; // Magic needs to be written as BE

function getMagicString(dataView) {
  return "".concat(String.fromCharCode(dataView.getUint8(0))).concat(String.fromCharCode(dataView.getUint8(1))).concat(String.fromCharCode(dataView.getUint8(2))).concat(String.fromCharCode(dataView.getUint8(3)));
} // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification


var GLBParser =
/*#__PURE__*/
function () {
  _createClass(GLBParser, null, [{
    key: "isGLB",
    value: function isGLB(glbArrayBuffer) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _options$magic = options.magic,
          magic = _options$magic === void 0 ? MAGIC_glTF : _options$magic; // Check that GLB Header starts with the magic number

      var dataView = new DataView(glbArrayBuffer);
      var magic1 = dataView.getUint32(0, BE);
      return magic1 === magic || magic1 === MAGIC_glTF;
    }
  }]);

  function GLBParser() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, GLBParser);

    // Result
    this.binaryByteOffset = null;
    this.packedJson = null;
    this.json = null;
  } // Return the gltf JSON and the original arrayBuffer


  _createClass(GLBParser, [{
    key: "parse",
    value: function parse(glbArrayBuffer) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // Input
      this.glbArrayBuffer = glbArrayBuffer; // Only parse once

      if (this.json === null && this.binaryByteOffset === null) {
        this.result = this._parse(options);
      }

      return this;
    } // Returns application JSON data stored in `key`

  }, {
    key: "getApplicationData",
    value: function getApplicationData(key) {
      return this.json[key];
    } // Returns JSON envelope

  }, {
    key: "getJSON",
    value: function getJSON() {
      return this.json;
    } // Return binary chunk

  }, {
    key: "getArrayBuffer",
    value: function getArrayBuffer() {
      return this.glbArrayBuffer;
    } // Return index into binary chunk

  }, {
    key: "getBinaryByteOffset",
    value: function getBinaryByteOffset() {
      return this.binaryByteOffset;
    } // Unpacks a bufferview into a new Uint8Array that is a view into the binary chunk

  }, {
    key: "getBufferView",
    value: function getBufferView(glTFBufferView) {
      var byteOffset = (glTFBufferView.byteOffset || 0) + this.binaryByteOffset;
      return new Uint8Array(this.glbArrayBuffer, byteOffset, glTFBufferView.byteLength);
    } // Unpacks a glTF accessor into a new typed array that is a view into the binary chunk

  }, {
    key: "getBuffer",
    value: function getBuffer(glTFAccessor) {
      // Decode the glTF accessor format
      var ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[glTFAccessor.componentType];
      var components = ATTRIBUTE_TYPE_TO_COMPONENTS[glTFAccessor.type];
      var bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[glTFAccessor.componentType];
      var length = glTFAccessor.count * components;
      var byteLength = glTFAccessor.count * components * bytesPerComponent; // Get the boundaries of the binary sub-chunk for this bufferView

      var glTFBufferView = this.json.bufferViews[glTFAccessor.bufferView];
      assert(byteLength >= 0 && byteLength <= glTFBufferView.byteLength);
      var byteOffset = glTFBufferView.byteOffset + this.binaryByteOffset;
      return new ArrayType(this.arrayBuffer, byteOffset, length);
    } // Unpacks an image into an HTML image

  }, {
    key: "getImageData",
    value: function getImageData(glTFImage) {
      return {
        typedArray: this.getBufferView(glTFImage.bufferView),
        mimeType: glTFImage.mimeType || 'image/jpeg'
      };
    }
  }, {
    key: "getImage",
    value: function getImage(glTFImage) {
      /* global self, Blob, Image */
      var arrayBufferView = this.getBufferView(glTFImage.bufferView);
      var mimeType = glTFImage.mimeType || 'image/jpeg';
      var blob = new Blob([arrayBufferView], {
        type: mimeType
      });
      var urlCreator = self.URL || self.webkitURL;
      var imageUrl = urlCreator.createObjectURL(blob);
      var img = new Image();
      img.src = imageUrl;
      return img;
    }
  }, {
    key: "getImageAsync",
    value: function getImageAsync(glTFImage) {
      var _this = this;

      /* global self, Blob, Image */
      return new Promise(function (resolve) {
        var arrayBufferView = _this.getBufferView(glTFImage.bufferView);

        var mimeType = glTFImage.mimeType || 'image/jpeg';
        var blob = new Blob([arrayBufferView], {
          type: mimeType
        });
        var urlCreator = self.URL || self.webkitURL;
        var imageUrl = urlCreator.createObjectURL(blob);
        var img = new Image();

        img.onload = function () {
          return resolve(img);
        };

        img.src = imageUrl;
      });
    } // PRIVATE

  }, {
    key: "_parse",
    value: function _parse(options) {
      var result = this._parseBinary(options);

      this.packedJson = result.json;
      this.unpackedBuffers = unpackGLBBuffers(this.glbArrayBuffer, this.json, this.binaryByteOffset);
      this.json = unpackBinaryJson(this.json, this.unpackedBuffers);
    }
  }, {
    key: "_parseBinary",
    value: function _parseBinary(options) {
      var _options$magic2 = options.magic,
          magic = _options$magic2 === void 0 ? MAGIC_glTF : _options$magic2; // GLB Header

      var dataView = new DataView(this.glbArrayBuffer);
      var magic1 = dataView.getUint32(0, BE); // Magic number (the ASCII string 'glTF').

      var version = dataView.getUint32(4, LE); // Version 2 of binary glTF container format

      var fileLength = dataView.getUint32(8, LE); // Total byte length of generated file

      var valid = magic1 === MAGIC_glTF || magic1 === magic;

      if (!valid) {
        console.warn("Invalid GLB magic string ".concat(getMagicString(dataView))); // eslint-disable-line
      }

      assert(version === 2, "Invalid GLB version ".concat(version, ". Only .glb v2 supported"));
      assert(fileLength > 20); // Write the JSON chunk

      var jsonChunkLength = dataView.getUint32(12, LE); // Byte length of json chunk

      var jsonChunkFormat = dataView.getUint32(16, LE); // Chunk format as uint32

      valid = jsonChunkFormat === GLB_CHUNK_TYPE_JSON || jsonChunkFormat === 0; // Back compat

      assert(valid, "JSON chunk format ".concat(jsonChunkFormat)); // Create a "view" of the binary encoded JSON data

      var jsonChunkOffset = GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE; // First headers: 20 bytes

      var jsonChunk = new Uint8Array(this.glbArrayBuffer, jsonChunkOffset, jsonChunkLength); // Decode the JSON binary array into clear text

      var textDecoder = new TextDecoder('utf8');
      var jsonText = textDecoder.decode(jsonChunk); // Parse the JSON text into a JavaScript data structure

      this.json = JSON.parse(jsonText); // TODO - BIN chunk can be optional

      var binaryChunkStart = jsonChunkOffset + padTo4Bytes(jsonChunkLength);
      this.binaryByteOffset = binaryChunkStart + GLB_CHUNK_HEADER_SIZE;
      var binChunkFormat = dataView.getUint32(binaryChunkStart + 4, LE); // Chunk format as uint32

      valid = binChunkFormat === GLB_CHUNK_TYPE_BIN || binChunkFormat === 1; // Back compat

      assert(valid, "BIN chunk format ".concat(binChunkFormat));
      return {
        arrayBuffer: this.glbArrayBuffer,
        binaryByteOffset: this.binaryByteOffset,
        json: this.json
      };
    }
  }]);

  return GLBParser;
}();

export { GLBParser as default };
//# sourceMappingURL=glb-parser.js.map