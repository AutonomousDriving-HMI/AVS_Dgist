"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _glbBuilder = _interopRequireDefault(require("../glb/glb-builder"));

var _packBinaryJson = _interopRequireDefault(require("../packed-json/pack-binary-json"));

var _core = require("@loaders.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// Ideally we should just use KHR_draco_mesh_compression, but it requires saving uncompressed data?
// TODO: until the ideal, we need to export these
var UBER_MESH_EXTENSION = 'UBER_draco_mesh_compression';
var UBER_POINT_CLOUD_EXTENSION = 'UBER_draco_point_cloud_compression';

var GLTFBuilder =
/*#__PURE__*/
function (_GLBBuilder) {
  _inherits(GLTFBuilder, _GLBBuilder);

  function GLTFBuilder() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, GLTFBuilder);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTFBuilder).call(this, options)); // Soft dependency on DRACO, app needs to import and supply these

    _this.DracoEncoder = options.DracoEncoder;
    _this.DracoDecoder = options.DracoDecoder;
    Object.assign(_this.json, {
      meshes: []
    });
    return _this;
  } // TODO - support encoding to non-GLB versions of glTF format
  // Encode as a textual JSON file with binary data in base64 data URLs.
  // encodeAsDataURLs(options) {
  //   throw new Error('Not yet implemented');
  // }
  // Encode as a JSON with all images (and buffers?) in separate binary files
  // encodeAsSeparateFiles(options) {
  //   throw new Error('Not yet imlemented');
  // }
  // Add an extra application-defined key to the top-level data structure
  // By default packs JSON by extracting binary data and replacing it with JSON pointers


  _createClass(GLTFBuilder, [{
    key: "addApplicationData",
    value: function addApplicationData(key, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var jsonData = packOptions.nopack ? data : (0, _packBinaryJson.default)(data, this, packOptions);
      this.json[key] = jsonData;
      return this;
    } // `extras` - Standard GLTF field for storing application specific data
    // By default packs JSON by extracting binary data and replacing it with JSON pointers

  }, {
    key: "addExtraData",
    value: function addExtraData(key, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var packedJson = !packOptions.nopack && (0, _packBinaryJson.default)(data, this, packOptions);
      this.json.extras = this.json.extras || {};
      this.json.extras[key] = packedJson;
      return this;
    } // Add to standard GLTF top level extension object, mark as used
    // By default packs JSON by extracting binary data and replacing it with JSON pointers

  }, {
    key: "addExtension",
    value: function addExtension(extensionName, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      (0, _core.assert)(data);
      var packedJson = !packOptions.nopack && (0, _packBinaryJson.default)(data, this, packOptions);
      this.json.extensions = this.json.extensions || {};
      this.json.extensions[extensionName] = packedJson;
      this.registerUsedExtension(extensionName);
      return this;
    } // Standard GLTF top level extension object, mark as used and required
    // By default packs JSON by extracting binary data and replacing it with JSON pointers

  }, {
    key: "addRequiredExtension",
    value: function addRequiredExtension(extensionName, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      (0, _core.assert)(data);
      var packedJson = !packOptions.nopack && (0, _packBinaryJson.default)(data, this, packOptions);
      this.addExtension(extensionName, packedJson);
      this.registerRequiredExtension(extensionName);
      return this;
    } // Add extensionName to list of used extensions

  }, {
    key: "registerUsedExtension",
    value: function registerUsedExtension(extensionName) {
      this.json.extensionsUsed = this.json.extensionsUsed || [];

      if (!this.json.extensionsUsed.find(function (ext) {
        return ext === extensionName;
      })) {
        this.json.extensionsUsed.push(extensionName);
      }
    } // Add extensionName to list of required extensions

  }, {
    key: "registerRequiredExtension",
    value: function registerRequiredExtension(extensionName) {
      this.registerUsedExtension(extensionName);
      this.json.extensionsRequired = this.json.extensionsRequired || [];

      if (!this.json.extensionsRequired.find(function (ext) {
        return ext === extensionName;
      })) {
        this.json.extensionsRequired.push(extensionName);
      }
    } // POINTS:  0x0000,
    // LINES: 0x0001,
    // LINE_LOOP: 0x0002,
    // LINE_STRIP:  0x0003,
    // TRIANGLES: 0x0004,
    // TRIANGLE_STRIP:  0x0005,
    // TRIANGLE_FAN:  0x0006,

  }, {
    key: "addMesh",
    value: function addMesh(attributes, indices) {
      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

      var accessors = this._addAttributes(attributes);

      var glTFMesh = {
        primitives: [{
          attributes: accessors,
          indices: indices,
          mode: mode
        }]
      };
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
  }, {
    key: "addPointCloud",
    value: function addPointCloud(attributes) {
      var accessorIndices = this._addAttributes(attributes);

      var glTFMesh = {
        primitives: [{
          attributes: accessorIndices,
          mode: 0 // GL.POINTS

        }]
      };
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    } // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/
    //   KHR_draco_mesh_compression
    // NOTE: in contrast to glTF spec, does not add fallback data

  }, {
    key: "addCompressedMesh",
    value: function addCompressedMesh(attributes, indices) {
      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

      if (!this.DracoEncoder || !this.DracoDecoder) {
        throw new Error('DracoEncoder/Decoder not available');
      }

      var dracoEncoder = new this.DracoEncoder();
      var compressedData = dracoEncoder.encodeMesh(attributes); // Draco compression may change the order and number of vertices in a mesh.
      // To satisfy the requirement that accessors properties be correct for both
      // compressed and uncompressed data, generators should create uncompressed
      // attributes and indices using data that has been decompressed from the Draco buffer,
      // rather than the original source data.

      var dracoDecoder = new this.DracoDecoder();
      var decodedData = dracoDecoder.decodeMesh(attributes);

      var fauxAccessors = this._addFauxAttributes(decodedData.attributes);

      var bufferViewIndex = this.addBufferView(compressedData);
      var glTFMesh = {
        primitives: [{
          attributes: fauxAccessors,
          mode: mode,
          // GL.POINTS
          extensions: _defineProperty({}, UBER_MESH_EXTENSION, {
            bufferView: bufferViewIndex
          })
        }]
      };
      this.registerRequiredExtension(UBER_MESH_EXTENSION);
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
  }, {
    key: "addCompressedPointCloud",
    value: function addCompressedPointCloud(attributes) {
      if (!this.DracoEncoder || !this.DracoDecoder) {
        throw new Error('DracoEncoder/Decoder not available');
      }

      var dracoEncoder = new this.DracoEncoder();
      var compressedData = dracoEncoder.encodePointCloud(attributes);
      var bufferViewIndex = this.addBufferView(compressedData);
      var glTFMesh = {
        primitives: [{
          attributes: {},
          // This will be populated after decompression
          mode: 0,
          // GL.POINTS
          extensions: _defineProperty({}, UBER_POINT_CLOUD_EXTENSION, {
            bufferView: bufferViewIndex
          })
        }]
      };
      this.registerRequiredExtension(UBER_POINT_CLOUD_EXTENSION);
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    } // Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
    // Buffer will be copied into BIN chunk during "pack"
    // Currently encodes as glTF image

  }, {
    key: "addImage",
    value: function addImage(imageData) {
      var bufferViewIndex = this.addBufferView(imageData); // Get the properties of the image to add as metadata.

      var sizeAndType = (0, _core.getImageSize)(imageData) || {};

      if (sizeAndType) {
        // width and height are non-spec fields
        var mimeType = sizeAndType.mimeType,
            width = sizeAndType.width,
            height = sizeAndType.height;
        this.json.images.push({
          bufferView: bufferViewIndex,
          mimeType: mimeType,
          width: width,
          height: height
        });
      } else {
        // TODO: Spec violation, if we are using a bufferView, mimeType must be defined
        //       https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images
        //       "a reference to a bufferView; in that case mimeType must be defined."
        this.json.images.push({
          bufferView: bufferViewIndex
        });
      }

      return this.json.images.length - 1;
    }
  }]);

  return GLTFBuilder;
}(_glbBuilder.default);

exports.default = GLTFBuilder;
//# sourceMappingURL=gltf-builder.js.map