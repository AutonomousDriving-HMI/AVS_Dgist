"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TRIGGERS = exports.POSITIONS = void 0;

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _popper = _interopRequireDefault(require("popper.js"));

var _styled = _interopRequireDefault(require("@emotion/styled"));

var _theme = require("../theme");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var isBrowser = typeof document !== 'undefined' && Boolean(document.createElement);
var POSITIONS = {
  TOP: 'top',
  RIGHT: 'right',
  BOTTOM: 'bottom',
  LEFT: 'left',
  AUTO: 'auto'
};
exports.POSITIONS = POSITIONS;
var TRIGGERS = {
  CLICK: 'click',
  HOVER: 'hover'
};
exports.TRIGGERS = TRIGGERS;
var DEFAULT_ARROW_SIZE = 6;
var DEFAULT_BORDER_WIDTH = 1;

var PopoverComponent = _styled.default.div(function (props) {
  return _objectSpread({
    /* Default wrapper style should ideally be display: inline so that popover
    shows directly beneath child content, inline-flex just generally works
    better than inline */
    display: 'inline-flex'
  }, (0, _theme.evaluateStyle)(props.userStyle, props));
});

var PopoverTarget = _styled.default.div(function (props) {
  return _objectSpread({}, (0, _theme.evaluateStyle)(props.userStyle, props));
});

var PopoverContent = _styled.default.div(function (props) {
  return _objectSpread({}, (0, _theme.evaluateStyle)(props.userStyle, props));
});

var PopoverBody = _styled.default.div(function (props) {
  var style = null;

  if (props.position && props.position !== POSITIONS.AUTO && props.arrowSize) {
    style = _defineProperty({}, "margin".concat((0, _utils.capitalize)((0, _utils.getOppositePosition)(props.position))), props.arrowSize);
  }

  return _objectSpread({}, props.theme.__reset__, style, {
    position: 'absolute',
    top: 0,
    left: 0,
    zIndex: 99,
    background: props.background || props.theme.background,
    borderStyle: 'solid',
    borderWidth: props.borderWidth,
    borderColor: props.borderColor || props.theme.controlColorPrimary,
    boxShadow: props.theme.shadow,
    fontFamily: props.theme.fontFamily,
    fontSize: props.theme.fontSize,
    fontWeight: 'normal'
  }, props.popperStyles, (0, _theme.evaluateStyle)(props.userStyle, props));
});

var OuterArrow = _styled.default.div(function (props) {
  /**
   * We create our arrow triangle using css borders, however this makes it
   * difficult for us to add an actual border effect to the triangle. In order
   * to achieve this effect, we generate two arrows and overlap themâ€“an outer
   * arrow with the border color, and an inner arrow with the background color.
   */
  var position = props.position,
      arrowSize = props.arrowSize,
      popperOffsets = props.popperOffsets;

  if (!arrowSize) {
    return null;
  }

  var arrowOffsets = popperOffsets.arrow || {};

  var style = _defineProperty({
    borderColor: props.borderColor || props.theme.controlColorPrimary
  }, (0, _utils.getOppositePosition)(position), -arrowSize); // Now apply arrow offsets calculated by popper library (if needed)


  if (arrowOffsets.top) {
    style.top = arrowOffsets.top;
  }

  if (arrowOffsets.left) {
    style.left = arrowOffsets.left;
  }

  return Object.assign(style, (0, _theme.evaluateStyle)(props.userStyle, props), (0, _utils.generateTriangleStyles)(position, arrowSize));
});

var InnerArrow = _styled.default.div(function (props) {
  var position = props.position,
      arrowSize = props.arrowSize;

  if (!arrowSize) {
    return null;
  }

  var isVertical = position === POSITIONS.TOP || position === POSITIONS.BOTTOM;
  var style = {
    borderColor: props.background || props.theme.background
  }; // Offset the inner arrow a couple pixels from its parent (the outer arrow)

  if (isVertical) {
    style.left = -arrowSize;
    style.top = position === POSITIONS.TOP ? -arrowSize : 0;
    style.marginTop = (position === POSITIONS.TOP ? -1 : 1) * props.borderWidth;
  } else {
    style.top = -arrowSize;
    style.left = position === POSITIONS.LEFT ? -arrowSize : 0;
    style.marginLeft = (position === POSITIONS.LEFT ? -1 : 1) * props.borderWidth;
  }

  return Object.assign(style, (0, _theme.evaluateStyle)(props.userStyle, props), (0, _utils.generateTriangleStyles)(position, arrowSize));
});

var POSITIONS_PROP_TYPE = _propTypes.default.oneOf([POSITIONS.TOP, POSITIONS.RIGHT, POSITIONS.BOTTOM, POSITIONS.LEFT, POSITIONS.AUTO]);

var Popover =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Popover, _React$Component);

  function Popover(props) {
    var _this;

    _classCallCheck(this, Popover);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Popover).call(this, props));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handleTargetClick", function () {
      _this._togglePopover();
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handleTargetMouseEnter", function () {
      // If onMouseOutDelay is set and mouse is moving from popper back to target,
      // we want to cancel any timers that would cause it to hide unexpectedly
      clearTimeout(_this.hideTimer);

      _this._showPopover();
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handleTargetMouseLeave", function () {
      _this._hidePopoverWithDelay();
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handlePopoverMouseEnter", function () {
      clearTimeout(_this.hideTimer);
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handlePopoverMouseLeave", function () {
      _this._hidePopoverWithDelay();
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handleKeyPress", function (evt) {
      if (evt.key === 'Escape') {
        _this._hidePopover();
      }
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handlePopperUpdate", function (data) {
      _this.setState({
        popperOffsets: data.offsets,
        popperPlacement: data.placement,
        popperStyles: data.styles
      });

      return data;
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_hidePopover", function () {
      _this.setState(_this._getDefaultState(_this.props));

      _this._destroyPopover();
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handleDocumentClick", function (evt) {
      if (!_this.$popper || (0, _utils.nodeHasParent)(evt.target, _this.$popper) || (0, _utils.nodeHasParent)(evt.target, _this.$target)) {
        return;
      }

      _this._hidePopover();
    });

    _this.state = _this._getDefaultState(props);
    return _this;
  }

  _createClass(Popover, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      // If we just switched to showing popover, create a new Popper for positioning
      if (this.state.isVisible && !prevState.isVisible) {
        var PopperClass = this.props.popperClass;
        this.popper = new PopperClass(this.$target, this.$popper, {
          placement: this.state.popperPlacement,
          modifiers: {
            // Passing the arrow ref will measure the arrow when calculating styles
            arrow: {
              element: this.$arrow,
              enabled: true
            },
            // Disable default styling modifier, and use our custom react one instead
            applyStyle: {
              enabled: false
            },
            applyReactStyle: {
              enabled: true,
              fn: this._handlePopperUpdate,
              order: 900
            }
          }
        });

        if (this.props.trigger === TRIGGERS.CLICK) {
          this._addClickEvents();
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._destroyPopover();

      this._removeClickEvents();
    }
  }, {
    key: "_getDefaultState",
    value: function _getDefaultState(props) {
      return {
        isVisible: false,
        popperOffsets: {},
        popperPlacement: (0, _utils.positionsToPopperPlacement)(props.position, props.arrowPosition),
        popperStyles: {}
      };
    }
  }, {
    key: "_showPopover",
    value: function _showPopover() {
      this.setState({
        isVisible: true
      });
    }
  }, {
    key: "_hidePopoverWithDelay",
    value: function _hidePopoverWithDelay() {
      var onMouseOutDelay = this.props.onMouseOutDelay;

      if (onMouseOutDelay) {
        this.hideTimer = setTimeout(this._hidePopover, onMouseOutDelay);
        return;
      }

      this._hidePopover();
    }
  }, {
    key: "_addClickEvents",
    value: function _addClickEvents() {
      if (!isBrowser) {
        return;
      }

      document.addEventListener('mousedown', this._handleDocumentClick);
      document.addEventListener('keyup', this._handleKeyPress);
    }
  }, {
    key: "_removeClickEvents",
    value: function _removeClickEvents() {
      if (!isBrowser) {
        return;
      }

      document.removeEventListener('mousedown', this._handleDocumentClick);
      document.removeEventListener('keyup', this._handleKeyPress);
    }
  }, {
    key: "_togglePopover",
    value: function _togglePopover() {
      var isVisible = !this.state.isVisible;
      this.setState({
        isVisible: isVisible
      });

      if (!isVisible) {
        this._destroyPopover();
      }
    }
  }, {
    key: "_destroyPopover",
    value: function _destroyPopover() {
      if (this.popper) {
        this.popper.destroy();
        delete this.popper;
      }

      if (this.props.trigger === TRIGGERS.CLICK) {
        this._removeClickEvents();
      }
    }
  }, {
    key: "_renderTarget",
    value: function _renderTarget(styleProps) {
      var _this2 = this;

      var _this$props = this.props,
          trigger = _this$props.trigger,
          style = _this$props.style;
      var interactionProps = {};

      if (trigger === TRIGGERS.HOVER) {
        interactionProps.onMouseEnter = this._handleTargetMouseEnter;
        interactionProps.onMouseLeave = this._handleTargetMouseLeave;
      } else if (trigger === TRIGGERS.CLICK) {
        interactionProps.onClick = this._handleTargetClick;
      }

      return _react.default.createElement(PopoverTarget, _extends({}, interactionProps, {
        userStyle: style.target
      }, styleProps, {
        ref: function ref(el) {
          _this2.$target = el;
        }
      }), this.props.children);
    }
  }, {
    key: "_renderArrow",
    value: function _renderArrow(styleProps) {
      var _this3 = this;

      var style = this.props.style;
      return _react.default.createElement(OuterArrow, _extends({
        userStyle: style.arrowBorder
      }, styleProps, {
        ref: function ref(el) {
          _this3.$arrow = el;
        }
      }), _react.default.createElement(InnerArrow, _extends({
        userStyle: style.arrow
      }, styleProps)));
    }
  }, {
    key: "_renderBody",
    value: function _renderBody(styleProps) {
      var _this4 = this;

      var _this$props2 = this.props,
          className = _this$props2.className,
          style = _this$props2.style,
          trigger = _this$props2.trigger;
      var interactionProps = {};

      if (trigger === TRIGGERS.HOVER) {
        interactionProps.onMouseEnter = this._handlePopoverMouseEnter;
        interactionProps.onMouseLeave = this._handlePopoverMouseLeave;
      }

      return _react.default.createElement(PopoverBody, _extends({
        className: className
      }, interactionProps, {
        userStyle: style.body
      }, styleProps, {
        ref: function ref(el) {
          _this4.$popper = el;
        }
      }), this._renderContent(styleProps), this._renderArrow(styleProps));
    }
  }, {
    key: "_renderContent",
    value: function _renderContent(styleProps) {
      var content = typeof this.props.content === 'function' ? this.props.content() : this.props.content;
      return _react.default.createElement(PopoverContent, _extends({
        userStyle: this.props.style.content
      }, styleProps), content);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          theme = _this$props3.theme,
          style = _this$props3.style;
      var _this$state = this.state,
          isVisible = _this$state.isVisible,
          popperPlacement = _this$state.popperPlacement,
          popperStyles = _this$state.popperStyles,
          popperOffsets = _this$state.popperOffsets;

      var _popperPlacement$spli = popperPlacement.split('-'),
          _popperPlacement$spli2 = _slicedToArray(_popperPlacement$spli, 1),
          position = _popperPlacement$spli2[0];

      var arrowPosition = position === POSITIONS.AUTO ? POSITIONS.TOP : position;
      var styleProps = {
        theme: theme,
        arrowSize: 'arrowSize' in style ? style.arrowSize : DEFAULT_ARROW_SIZE,
        background: style.background,
        borderWidth: 'borderWidth' in style ? style.borderWidth : DEFAULT_BORDER_WIDTH,
        borderColor: style.borderColor,
        position: position,
        arrowPosition: arrowPosition,
        popperStyles: popperStyles,
        popperOffsets: popperOffsets,
        isActive: isVisible
      };
      return _react.default.createElement(PopoverComponent, _extends({
        userStyle: style.popover
      }, styleProps), this._renderTarget(styleProps), isVisible && this._renderBody(styleProps));
    }
  }]);

  return Popover;
}(_react.default.Component);

_defineProperty(Popover, "propTypes", {
  className: _propTypes.default.string,
  style: _propTypes.default.object,
  content: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]).isRequired,
  position: POSITIONS_PROP_TYPE,
  // Arrow options
  arrowPosition: POSITIONS_PROP_TYPE,
  // Interaction
  onMouseOutDelay: _propTypes.default.number,
  trigger: _propTypes.default.oneOf([TRIGGERS.HOVER, TRIGGERS.CLICK]),
  // Support injecting mock Popper class for tests
  popperClass: _propTypes.default.func
});

_defineProperty(Popover, "defaultProps", {
  className: '',
  style: {},
  trigger: TRIGGERS.CLICK,
  onMouseOutDelay: 0,
  popperClass: _popper.default
});

var ThemedPopover = (0, _theme.withTheme)(Popover);
Object.assign(ThemedPopover, POSITIONS);
Object.assign(ThemedPopover, TRIGGERS);
var _default = ThemedPopover;
exports.default = _default;
//# sourceMappingURL=popover.js.map