function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Copyright (c) 2019 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { getXVIZConfig } from '../config/xviz-config';
import xvizStats from '../utils/stats';
import LogSlice from './log-slice';
import memoize from '../utils/memoize';
import assert from '../utils/assert'; // MEMOIZATION OF LOGSLICE CONSTRUCTOR AND GET METHOD

var getCurrentLogSliceMemoized = memoize(function (streamFilter, lookAheadMs) {
  xvizStats.bump('getCurrentLogSliceMemoized');

  for (var _len = arguments.length, streamsByReverseTime = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    streamsByReverseTime[_key - 2] = arguments[_key];
  }

  return new LogSlice(streamFilter, lookAheadMs, streamsByReverseTime);
});
var getCurrentFrameMemoized = memoize(function (logSlice, vehiclePose, trackedObjectId, postProcessFrame) {
  return logSlice.getCurrentFrame({
    vehiclePose: vehiclePose,
    trackedObjectId: trackedObjectId
  }, postProcessFrame);
});
var EMPTY_VEHICLE_POSE = {
  longitude: 0,
  latitude: 0,
  x: 0,
  y: 0,
  z: 0
};
/**
 * Synchronizes log data across streams and provide the latest data
 * "closest" to a given timestamp within a time window.
 *
 * NOTES:
 * - logs typically use GPS time (no leap seconds)
 *   - Definition: http://www.leapsecond.com/java/gpsclock.htm
 *   - Web conversion: https://www.andrews.edu/~tzs/timeconv/timeconvert.php
 *   - Javascript conversion: https://www.npmjs.com/package/gps-time
 * - should vehicle_pose be selected based on time closes to the set time?
 *   It remains unclear what stream data is derived from which vehicle_pose
 *   due to the propogation of data thru the system.
 *
 * @param {Object[]} slices - Array of timeslices
 * - Each timeslice object must contain a GPS timestamp
 */

var BaseSynchronizer =
/*#__PURE__*/
function () {
  function BaseSynchronizer() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, BaseSynchronizer);

    this.opts = opts;
    this.time = 0;
    this.lookAheadMs = 0;
  } // The "frame" contains the processed and combined data from the current log slice


  _createClass(BaseSynchronizer, [{
    key: "getCurrentFrame",
    value: function getCurrentFrame(streamFilter, trackedObjectId) {
      xvizStats.bump('getCurrentFrame');
      var logSlice = this.getLogSlice(streamFilter);

      if (!logSlice) {
        return null;
      }

      var _getXVIZConfig = getXVIZConfig(),
          PRIMARY_POSE_STREAM = _getXVIZConfig.PRIMARY_POSE_STREAM,
          ALLOW_MISSING_PRIMARY_POSE = _getXVIZConfig.ALLOW_MISSING_PRIMARY_POSE; // If a missing primary pose stream is allowed, then set the default pose
      // value to origin.


      var defaultPose = ALLOW_MISSING_PRIMARY_POSE ? EMPTY_VEHICLE_POSE : null;
      var vehiclePose = logSlice.getStream(PRIMARY_POSE_STREAM, defaultPose);

      if (vehiclePose !== this._lastVehiclePose) {
        xvizStats.bump('vehiclePose');
        this._lastVehiclePose = vehiclePose;
      }

      return getCurrentFrameMemoized(logSlice, vehiclePose, trackedObjectId, this.opts.postProcessFrame);
    } // @return {Number} Currently set time

  }, {
    key: "getTime",
    value: function getTime() {
      return this.time;
    }
    /**
     * @param {Number} time - time to synchronize the logs with
     * @return {StreamSynchronizer} - returns itself for chaining.
     */

  }, {
    key: "setTime",
    value: function setTime(time) {
      this.time = time;
      assert(Number.isFinite(this.time), 'Invalid time');
      return this;
    }
    /**
     * Set the lookAhead time offset.
     *
     * @param {Number} offset - milliseconds into the future
     * @return {LogSynchronizer} - returns itself for chaining
     */

  }, {
    key: "setLookAheadTimeOffset",
    value: function setLookAheadTimeOffset(offset) {
      // Change the offset time into an index.
      this.lookAheadMs = offset;
      return this;
    } // HELPER METHODS
    // Get data for current time...
    // @return {Object} - keys are stream names
    //  values are the datum from each stream that best matches the current time.

  }, {
    key: "getLogSlice",
    value: function getLogSlice(streamFilter) {
      if (this._empty()) {
        return null;
      } // Find the right timeslices


      var _getXVIZConfig2 = getXVIZConfig(),
          TIME_WINDOW = _getXVIZConfig2.TIME_WINDOW;

      this._streamsByReverseTime = this._getTimeRangeInReverse(this.time - TIME_WINDOW, this.time);
      xvizStats.bump('geometry-refresh');
      return getCurrentLogSliceMemoized.apply(void 0, [streamFilter, this.lookAheadMs].concat(_toConsumableArray(this._streamsByReverseTime)));
    } // PROTECTED API - DEFINED BY DERIVED CLASES

  }, {
    key: "empty",
    value: function empty() {
      assert(false);
    }
    /**
     * Find and process stream data in the range (start, end] for process
     * Returns a list of streams sorted by descending time
     * Since we have all samples and can find the exact datum for the stream i
     * there is no "range" of samples to process and the reverse ordering does not apply.
     * @param Number startTime - The time to start from.
     * @param Number endTime - The time to end at.
     */

  }, {
    key: "_getTimeRangeInReverse",
    value: function _getTimeRangeInReverse(startTime, endTime) {
      assert(false);
    }
  }]);

  return BaseSynchronizer;
}();

export { BaseSynchronizer as default };
//# sourceMappingURL=base-synchronizer.js.map