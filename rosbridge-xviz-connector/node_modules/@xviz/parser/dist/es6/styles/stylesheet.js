function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

// Copyright (c) 2019 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/* eslint-disable no-console no-undef */
import XVIZStyleProperty from './xviz-style-property';
const SELECTOR_REGEX = /\S+/g;
const OPERATOR_REGEX = /([=:~\*\^]+)/;

const NULL_VALIDATOR = () => true;
/* Parser for single stylesheet */


export default class Stylesheet {
  constructor() {
    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    const rules = data.slice() // Newer rules override older ones
    .reverse().map(rule => {
      const _this$_parseSelector = this._parseSelector(rule.name || '*'),
            selectors = _this$_parseSelector.selectors,
            validate = _this$_parseSelector.validate;

      const properties = this._parseProperties(rule);

      return {
        selectors,
        validate,
        properties
      };
    });
    this.properties = {};
    rules.forEach(rule => {
      for (const key in rule.properties) {
        let p = this.properties[key];

        if (!p) {
          p = [];
          this.properties[key] = p;
        }

        p.push(rule);
      }
    });
    this.rules = rules;
  } // Public methods

  /**
   * get style by property name for an object
   * @param {String} propertyName - name of the style
   * @param {Object} state - state descriptor of the object, used to match selectors
   * @returns {Number|String|Array} style property value
   */


  getProperty(propertyName) {
    let state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    // inline style override any generic rules
    const inlineProp = state.base && state.base.style && state.base.style[propertyName];

    if (inlineProp !== undefined) {
      return XVIZStyleProperty.formatValue(propertyName, inlineProp);
    }

    const rules = this.properties[propertyName];
    const match = rules && rules.find(rule => rule.validate(state));
    return match ? match.properties[propertyName].getValue(state) : null;
  }
  /**
   * get default style by property name
   * @param {String} propertyName - name of the style
   * @returns {Number|String|Array} style property default value
   */


  getPropertyDefault(propertyName) {
    const value = XVIZStyleProperty.getDefault(propertyName);

    if (typeof value === 'function') {
      return value(this);
    }

    return value;
  }
  /**
   * get a list of attribute names that a property depends on.
   * @param {String} propertyName - name of the style
   * @returns {Array} - attribute names
   */


  getPropertyDependencies(propertyName) {
    const attributes = {};
    const rules = this.properties[propertyName];

    if (!rules) {
      return [];
    }

    rules.forEach(rule => {
      rule.selectors.forEach(selector => {
        if (selector !== '*') {
          const _selector$split = selector.split(OPERATOR_REGEX),
                _selector$split2 = _slicedToArray(_selector$split, 1),
                name = _selector$split2[0];

          attributes[name] = 1;
        }
      });
    });
    return Object.keys(attributes);
  } // Private methods
  // Returns a function that checks if an object matches the given selector expressions


  _getValidator(selector) {
    if (selector === '*') {
      return NULL_VALIDATOR;
    }

    const _selector$split3 = selector.split(OPERATOR_REGEX),
          _selector$split4 = _slicedToArray(_selector$split3, 3),
          name = _selector$split4[0],
          operator = _selector$split4[1],
          value = _selector$split4[2];

    switch (operator) {
      case '=':
        return object => object && object[name] === value;

      default:
        {
          return object => {
            const classes = object && object.base && object.base.classes;
            return object && (classes && classes.includes(name) || object[name]);
          };
        }
    }
  } // Parses a selectorString (space-separated selector expressions)


  _parseSelector(selectorString) {
    const selectors = selectorString.match(SELECTOR_REGEX);
    let validate; // Special case handling
    // Better perf than Array.every

    if (selectors.length === 0 || selectors.includes('*')) {
      validate = NULL_VALIDATOR;
    } else if (selectors.length === 1) {
      const match = this._getValidator(selectors[0]);

      validate = object => match(object) || match(object.state);
    } else {
      const validators = selectors.map(this._getValidator);

      validate = object => validators.every(match => match(object) || match(object.state));
    }

    return {
      selectors,
      validate
    };
  } // Parses property values


  _parseProperties(properties) {
    const result = {};

    for (const key in properties.style) {
      result[key] = new XVIZStyleProperty(key, properties.style[key]);
    }

    return result;
  }

}
//# sourceMappingURL=stylesheet.js.map