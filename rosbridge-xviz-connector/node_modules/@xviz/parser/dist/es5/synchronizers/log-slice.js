"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _xvizConfig = require("../config/xviz-config");

var _xvizObject = _interopRequireDefault(require("../objects/xviz-object"));

var _search = require("../utils/search");

var _log = _interopRequireDefault(require("../utils/log"));

var _parseVehiclePose = require("../parsers/parse-vehicle-pose");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// lookAheads is an array of arrays, so we need to fetch out the first
// timestamp of the inner array.
function lookAheadTimesliceAccessor(timeslice) {
  if (timeslice && timeslice.length) {
    return timeslice[0].timestamp;
  }

  _log.default.warn('Missing entry or timestamp in lookAhead array')();

  return 0;
}

function updateObjects(streamName, features) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = features[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var feature = _step.value;

      var xvizObject = _xvizObject.default.get(feature.id);

      if (xvizObject) {
        xvizObject._addFeature(streamName, feature);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
} // LOGSLICE CLASS
// One time slice, one datum from each stream.


var LogSlice =
/*#__PURE__*/
function () {
  function LogSlice(streamFilter, lookAheadMs, streamsByReverseTime) {
    _classCallCheck(this, LogSlice);

    this.features = {};
    this.variables = {};
    this.pointCloud = null;
    this.lookAheads = {};
    this.components = {};
    this.streams = {};
    this.initialize(streamFilter, lookAheadMs, streamsByReverseTime);
  } // Extract car data from vehicle_pose and get geoJson for related frames

  /* eslint-disable max-statements */


  _createClass(LogSlice, [{
    key: "getCurrentFrame",
    value: function getCurrentFrame(params, postProcessFrame) {
      var vehiclePose = params.vehiclePose;

      if (!vehiclePose) {
        return null;
      }

      var _getXVIZConfig = (0, _xvizConfig.getXVIZConfig)(),
          OBJECT_STREAM = _getXVIZConfig.OBJECT_STREAM;

      var frame = _objectSpread({}, params, (0, _parseVehiclePose.getTransformsFromPose)(vehiclePose), {
        vehiclePose: vehiclePose,
        features: this.features,
        lookAheads: this.lookAheads,
        variables: this.variables,
        pointCloud: this.pointCloud,
        components: this.components,
        streams: this.streams
      }); // OBJECTS


      _xvizObject.default.resetAll();

      if (postProcessFrame) {
        postProcessFrame(frame);
      } // OBJECT_STREAM is deprecated, only keeping for backward compatibility


      if (OBJECT_STREAM) {
        updateObjects(OBJECT_STREAM, this.features[OBJECT_STREAM] || []);
      } else {
        for (var streamName in this.features) {
          var features = this.features[streamName];

          if (features.length && features[0].id) {
            updateObjects(streamName, features);
          }
        }
      }

      frame.objects = _xvizObject.default.getAllInCurrentFrame(); // Map of XVIZ ids in current slice

      return frame;
    }
    /* eslint-enable max-statements */
    // HELPER METHODS

    /**
     * In-contrast to the per-stream post-processors,
     * this function has the ability to look at and correlate data from multiple streams.
     * Among other things parses XVIZ Object-related info from misc streams and merge into XVIZ
     * feature properties.
     */

  }, {
    key: "initialize",
    value: function initialize(streamFilter, lookAheadMs, streamsByReverseTime) {
      var _this = this;

      var filter = streamFilter && Object.keys(streamFilter).length > 0 ? streamFilter : null; // get data if we don't already have that stream && it is not filtered.

      streamsByReverseTime.forEach(function (streams) {
        for (var streamName in streams) {
          if (!_this.streams[streamName] && _this._includeStream(filter, streamName)) {
            _this.addStreamDatum(streams[streamName], streamName, lookAheadMs, _this);
          }
        }
      });
    }
    /**
     * Process a stream and put the appropriate data into
     */

  }, {
    key: "addStreamDatum",
    value: function addStreamDatum(datum, streamName, lookAheadMs) {
      this.streams[streamName] = datum;
      this.setLabelsOnXVIZObjects(datum.labels);
      var _datum$features = datum.features,
          features = _datum$features === void 0 ? [] : _datum$features,
          _datum$lookAheads = datum.lookAheads,
          lookAheads = _datum$lookAheads === void 0 ? [] : _datum$lookAheads,
          variable = datum.variable,
          _datum$pointCloud = datum.pointCloud,
          pointCloud = _datum$pointCloud === void 0 ? null : _datum$pointCloud; // Future data is separate from features so we can control independently

      if (lookAheads.length && lookAheadMs > 0) {
        var lookAheadTime = datum.time + lookAheadMs;
        var lookAheadIndex = (0, _search.findInsertPos)(lookAheads, lookAheadTime, _search.INSERT_POSITION.RIGHT, lookAheadTimesliceAccessor);

        if (lookAheadIndex) {
          this.lookAheads[streamName] = lookAheads[lookAheadIndex - 1];
        }
      } // Combine data from current datums


      if (features.length) {
        this.features[streamName] = features;
      } // Point cloud


      if (pointCloud) {
        if (this.pointCloud) {
          console.warn("Point cloud for ".concat(streamName, " overwriting previous cloud")); // eslint-disable-line
        }

        this.pointCloud = pointCloud;
      }

      if (variable !== undefined) {
        this.variables[streamName] = variable;
      }
    }
  }, {
    key: "setLabelsOnXVIZObjects",
    value: function setLabelsOnXVIZObjects() {
      var labels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      // Sort labels by id
      labels.forEach(function (label) {
        var object = _xvizObject.default.get(label.id);

        if (object && label.labelName) {
          // Extract label name (acceleration, velocity etc.) from stream name
          // For streams that do not follow the simple pattern in STREAM_REGEXP
          // Lookup for exact matches for labels first.
          object._setProp(label.labelName, label.value);
        }
      });
    } // Helper function to get a stream from data
    // @param {Object} data - log data
    // @param {String} stream - name of stream
    // @param {*} defaultValue={} - return value in case stream is not present
    // @return {Object} - contents of stream or defaultValue

  }, {
    key: "getStream",
    value: function getStream(stream) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var streamData = this.streams[stream];

      if (!streamData) {
        return defaultValue;
      }

      return streamData;
    }
  }, {
    key: "_includeStream",
    value: function _includeStream(streamFilter, streamName) {
      return !streamFilter || streamFilter[streamName];
    }
  }]);

  return LogSlice;
}();

exports.default = LogSlice;
//# sourceMappingURL=log-slice.js.map