{"version":3,"sources":["../../../src/synchronizers/base-synchronizer.js"],"names":["getCurrentLogSliceMemoized","streamFilter","lookAheadMs","xvizStats","bump","streamsByReverseTime","LogSlice","getCurrentFrameMemoized","logSlice","vehiclePose","trackedObjectId","postProcessFrame","getCurrentFrame","BaseSynchronizer","opts","time","loResTime","getLogSlice","PRIMARY_POSE_STREAM","getStream","_lastVehiclePose","PLAYBACK_FRAME_RATE","Math","round","Number","isFinite","offset","_empty","TIME_WINDOW","_lastLoResTime","_streamsByReverseTime","_getTimeRangeInReverse","startTime","endTime"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {getXVIZConfig} from '../config/xviz-config';\nimport xvizStats from '../utils/stats';\nimport LogSlice from './log-slice';\n\nimport memoize from '../utils/memoize';\nimport assert from '../utils/assert';\n\n// MEMOIZATION OF LOGSLICE CONSTRUCTOR AND GET METHOD\nconst getCurrentLogSliceMemoized = memoize((streamFilter, lookAheadMs, ...streamsByReverseTime) => {\n  xvizStats.bump('getCurrentLogSliceMemoized');\n  return new LogSlice(streamFilter, lookAheadMs, streamsByReverseTime);\n});\n\nconst getCurrentFrameMemoized = memoize(\n  (logSlice, vehiclePose, trackedObjectId, postProcessFrame) => {\n    return logSlice.getCurrentFrame({vehiclePose, trackedObjectId}, postProcessFrame);\n  }\n);\n\n/**\n * Synchronizes log data across streams and provide the latest data\n * \"closest\" to a given timestamp within a time window.\n *\n * NOTES:\n * - logs typically use GPS time (no leap seconds)\n *   - Definition: http://www.leapsecond.com/java/gpsclock.htm\n *   - Web conversion: https://www.andrews.edu/~tzs/timeconv/timeconvert.php\n *   - Javascript conversion: https://www.npmjs.com/package/gps-time\n * - should vehicle_pose be selected based on time closes to the set time?\n *   It remains unclear what stream data is derived from which vehicle_pose\n *   due to the propogation of data thru the system.\n *\n * @param {Object[]} slices - Array of timeslices\n * - Each timeslice object must contain a GPS timestamp\n */\nexport default class BaseSynchronizer {\n  constructor(opts = {}) {\n    this.opts = opts;\n\n    this.time = 0;\n    this.loResTime = 0;\n    this.lookAheadMs = 0;\n  }\n\n  // The \"frame\" contains the processed and combined data from the current log slice\n  getCurrentFrame(streamFilter, trackedObjectId) {\n    xvizStats.bump('getCurrentFrame');\n\n    const logSlice = this.getLogSlice(streamFilter);\n    if (!logSlice) {\n      return null;\n    }\n\n    const {PRIMARY_POSE_STREAM} = getXVIZConfig();\n    const vehiclePose = logSlice.getStream(PRIMARY_POSE_STREAM, null);\n\n    if (vehiclePose !== this._lastVehiclePose) {\n      xvizStats.bump('vehiclePose');\n      this._lastVehiclePose = vehiclePose;\n    }\n\n    return getCurrentFrameMemoized(\n      logSlice,\n      vehiclePose,\n      trackedObjectId,\n      this.opts.postProcessFrame\n    );\n  }\n\n  // @return {Number} Currently set time\n  getTime() {\n    return this.time;\n  }\n\n  // The low resolution time is rounded to bigger intervals, throttling updates\n  getLoResTime() {\n    return this.loResTime;\n  }\n\n  /**\n   * @param {Number} time - time to synchronize the logs with\n   * @return {StreamSynchronizer} - returns itself for chaining.\n   */\n  setTime(time) {\n    const {PLAYBACK_FRAME_RATE} = getXVIZConfig();\n    this.time = time;\n    this.loResTime = Math.round(time * PLAYBACK_FRAME_RATE) / PLAYBACK_FRAME_RATE;\n    assert(Number.isFinite(this.time), 'Invalid time');\n    return this;\n  }\n\n  /**\n   * Set the lookAhead time offset.\n   *\n   * @param {Number} offset - milliseconds into the future\n   * @return {LogSynchronizer} - returns itself for chaining\n   */\n  setLookAheadTimeOffset(offset) {\n    // Change the offset time into an index.\n    this.lookAheadMs = offset;\n    return this;\n  }\n\n  // HELPER METHODS\n\n  // Get data for current time...\n  // @return {Object} - keys are stream names\n  //  values are the datum from each stream that best matches the current time.\n  getLogSlice(streamFilter) {\n    if (this._empty()) {\n      return null;\n    }\n\n    // Find the right timeslices\n    const {TIME_WINDOW} = getXVIZConfig();\n    this._lastLoResTime = this.loResTime;\n    this._streamsByReverseTime = this._getTimeRangeInReverse(\n      this.loResTime - TIME_WINDOW,\n      this.loResTime\n    );\n    xvizStats.bump('geometry-refresh');\n\n    return getCurrentLogSliceMemoized(\n      streamFilter,\n      this.lookAheadMs,\n      ...this._streamsByReverseTime\n    );\n  }\n\n  // PROTECTED API - DEFINED BY DERIVED CLASES\n\n  empty() {\n    assert(false);\n  }\n\n  /**\n   * Find and process stream data in the range (start, end] for process\n   * Returns a list of streams sorted by descending time\n   * Since we have all samples and can find the exact datum for the stream i\n   * there is no \"range\" of samples to process and the reverse ordering does not apply.\n   * @param Number startTime - The time to start from.\n   * @param Number endTime - The time to end at.\n   */\n  _getTimeRangeInReverse(startTime, endTime) {\n    assert(false);\n  }\n}\n"],"file":"base-synchronizer.js"}