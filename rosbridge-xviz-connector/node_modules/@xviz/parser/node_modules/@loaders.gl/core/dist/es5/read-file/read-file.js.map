{"version":3,"sources":["../../../src/read-file/read-file.js"],"names":["isNode","Boolean","fs","readFile","DEFAULT_OPTIONS","dataType","getReadFileOptions","options","Object","assign","responseType","encoding","uri","startsWith","Promise","resolve","File","readFileObject","isRequest","reject","URL","request","https","http","response","then","readFileNode","location","href","fetch","res","error","message","readFileSync","buffer","Buffer","file","reader","FileReader","onerror","Error","onabort","onload","result","readAsText","readAsArrayBuffer","filename","readFileAsync","util","promisify"],"mappings":"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","sourcesContent":["/* global fetch */\n/* global URL, location, File, FileReader */\n/* global Buffer */\nimport fs from 'fs'; // `fs` will be empty object in browsers (see package.json \"browser\" field).\nimport http from 'http';\nimport https from 'https';\nimport util from 'util';\n\nimport {resolvePath} from './file-aliases';\nimport decodeDataUri from '../data-uri-utils/decode-data-uri';\nimport {toArrayBuffer} from '../binary-utils/binary-utils';\nimport {concatenateReadStream} from '../async-iterator-utils/stream-utils';\n\nconst isNode = Boolean(fs && fs.readFile);\n\nconst DEFAULT_OPTIONS = {\n  dataType: 'arrayBuffer'\n};\n\nfunction getReadFileOptions(options = {}) {\n  options = Object.assign({}, DEFAULT_OPTIONS, options);\n  options.responseType = options.responseType || options.dataType;\n  if (fs) {\n    // set encoding for fs.readFile\n    options.encoding = options.encoding || (options.dataType === 'text' ? 'utf8' : null);\n  }\n  return options;\n}\n\n// Reads raw file data from:\n// * http/http urls\n// * data urls\n// * File/Blob objects\n// etc?\nexport function readFile(uri, options = {}) {\n  try {\n    uri = resolvePath(uri);\n    options = getReadFileOptions(options);\n\n    if (uri.startsWith('data:')) {\n      return Promise.resolve(decodeDataUri(uri));\n    }\n\n    if (typeof File !== 'undefined' && uri instanceof File) {\n      readFileObject(uri, options);\n    }\n\n    if (isNode) {\n      const isRequest = uri.startsWith('http:') || uri.startsWith('https:');\n      if (isRequest) {\n        return new Promise((resolve, reject) => {\n          options = {...new URL(uri), ...options};\n          const request = uri.startsWith('https:') ? https.request : http.request;\n          request(uri, response => concatenateReadStream(response).then(resolve, reject));\n        });\n      }\n\n      return readFileNode(uri, options);\n    }\n\n    // Browser: Try to load all URLS via fetch, as they can be local requests (e.g. to a dev server)\n    // In a web worker, XMLHttpRequest throws invalid URL error if using relative path\n    // resolve url relative to original base\n    uri = new URL(uri, location.href).href;\n    return fetch(uri, options).then(res => res[options.dataType]());\n\n    // return Promise.reject(new Error('Cannot load file URIs in browser'));\n  } catch (error) {\n    return Promise.reject(error.message);\n  }\n}\n\n// In a few cases (data URIs, node.js) \"files\" can be read synchronously\nexport function readFileSync(uri, options = {}) {\n  uri = resolvePath(uri);\n  options = getReadFileOptions(options);\n\n  if (uri.startsWith('data:')) {\n    return decodeDataUri(uri);\n  }\n\n  if (!isNode) {\n    return null; // throw new Error('Cant load URI synchronously');\n  }\n\n  const buffer = fs.readFileSync(uri, options, () => {});\n  return buffer instanceof Buffer ? toArrayBuffer(buffer) : buffer;\n}\n\n// HELPERS\n\n/**\n * File reader function for the browser\n * @param {File|Blob} file  HTML File or Blob object to read as string\n * @returns {Promise.string}  Resolves to a string containing file contents\n */\nfunction readFileObject(file, options) {\n  return new Promise((resolve, reject) => {\n    try {\n      const reader = new FileReader();\n      reader.onerror = error => reject(new Error(error));\n      reader.onabort = () => reject(new Error('Read operation was aborted.'));\n      reader.onload = () => resolve(reader.result);\n      if (options.dataType !== 'arraybuffer') {\n        reader.readAsText(file);\n      } else {\n        reader.readAsArrayBuffer(file);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\nfunction readFileNode(filename, options) {\n  const readFileAsync = util.promisify(fs.readFile);\n  return readFileAsync(filename, options).then(\n    buffer => buffer instanceof Buffer ? toArrayBuffer(buffer) : buffer\n  );\n}\n\n"],"file":"read-file.js"}