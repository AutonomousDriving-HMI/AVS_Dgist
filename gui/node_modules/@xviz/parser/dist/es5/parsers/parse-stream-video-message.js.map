{"version":3,"sources":["../../../src/parsers/parse-stream-video-message.js"],"names":["parseStreamVideoMessage","message","onResult","onError","Blob","then","arrayBuffer","catch","data","JSON","parse","result","parseStreamVideoData","error","ArrayBuffer","parseVideoFrame","type","parseVideoMetadata","LOG_STREAM_MESSAGE","ERROR","VIDEO_METADATA","view","DataView","VIDEO_FRAME","littleEndian","utf8Decoder","TextDecoder","offset","version","getUint32","versionFlags","streamLength","stringStart","stream","decode","slice","timestamp","getFloat64","imageSize","imageData","imageType"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * This file contains parsers for XVIZ video stream protocol.\n * Naming conventions:\n * `message` refers to the raw message received via webSocket.onmessage\n * `data` refers to pre-processed data objects (blob, arraybuffer, JSON object)\n */\n/* global Blob */\nimport {LOG_STREAM_MESSAGE} from '../constants';\nimport {TextDecoder} from '../utils/text-encoding';\nimport {blobToArrayBuffer} from '../utils/binary';\n\nimport {parseLogMetadata} from './parse-log-metadata';\n\n// Handle messages from the stand alone video server\nexport function parseStreamVideoMessage(message, onResult, onError) {\n  if (message instanceof Blob) {\n    blobToArrayBuffer(message)\n      .then(arrayBuffer => {\n        parseStreamVideoMessage(arrayBuffer, onResult, onError);\n      })\n      .catch(onError);\n    return;\n  }\n\n  try {\n    let data = message;\n    if (typeof message === 'string') {\n      data = JSON.parse(message);\n    }\n    const result = parseStreamVideoData(data);\n    onResult(result);\n  } catch (error) {\n    onError(error);\n  }\n}\n\n// Handle messages from the stand alone video server\nexport function parseStreamVideoData(data) {\n  if (data instanceof ArrayBuffer) {\n    return parseVideoFrame(data);\n  }\n  if (data.type === 'metadata') {\n    return parseVideoMetadata(data);\n  }\n  // Unknown message\n  return {type: LOG_STREAM_MESSAGE.ERROR, message: 'Unknown stream data type', data};\n}\n\n// Extract metadata from stream message\nfunction parseVideoMetadata(data) {\n  const result = parseLogMetadata(data);\n  result.type = LOG_STREAM_MESSAGE.VIDEO_METADATA;\n\n  return result;\n}\n\n// Parse image data from stream message\n// https://code.int.uberatc.com/diffusion/AV/browse/master/source/xviz/services/video/www/index.js\nexport function parseVideoFrame(arrayBuffer) {\n  const view = new DataView(arrayBuffer);\n\n  // Read off version\n  const result = {type: LOG_STREAM_MESSAGE.VIDEO_FRAME};\n  const littleEndian = true;\n  const utf8Decoder = new TextDecoder('utf-8');\n\n  // Check version\n  let offset = 0;\n  result.version = view.getUint32(offset, littleEndian);\n  offset += 4;\n  result.versionFlags = view.getUint32(offset, littleEndian);\n  offset += 4;\n\n  // Read off stream name\n  const streamLength = view.getUint32(offset, littleEndian);\n  const stringStart = offset + 4;\n  offset += 4 + streamLength;\n\n  result.stream = utf8Decoder.decode(arrayBuffer.slice(stringStart, offset));\n\n  // Read off timestamp\n  result.timestamp = view.getFloat64(offset, littleEndian);\n  offset += 8;\n\n  // Read slice off the image data\n  const imageSize = view.getUint32(offset, littleEndian);\n  offset += 4;\n\n  result.imageData = arrayBuffer.slice(offset, offset + imageSize);\n  result.imageType = 'image/jpeg';\n\n  return result;\n}\n"],"file":"parse-stream-video-message.js"}