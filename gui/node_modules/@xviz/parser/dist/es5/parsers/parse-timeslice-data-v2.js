"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseStreamSet;

var _constants = require("../constants");

var _xvizConfig = require("../config/xviz-config");

var _parseXvizPose = require("./parse-xviz-pose");

var _parseXvizStream = require("./parse-xviz-stream");

var _log = _interopRequireDefault(require("../utils/log"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

/* eslint-disable camelcase */
function parseStreamSet(data, convertPrimitive) {
  var update_type = data.update_type,
      updates = data.updates;

  if (update_type !== 'snapshot') {
    _log.default.error("Only XVIZ update_type of \"snapshot\" is currently supported. Type \"".concat(update_type, "\" is not supported."))();

    return {
      type: _constants.LOG_STREAM_MESSAGE.INCOMPLETE,
      message: 'Unsupported update type'
    };
  }

  if (!updates) {
    return {
      type: _constants.LOG_STREAM_MESSAGE.INCOMPLETE,
      message: 'Missing required "updates" property'
    };
  }

  if (updates && updates.length === 0) {
    return {
      type: _constants.LOG_STREAM_MESSAGE.INCOMPLETE,
      message: 'Property "updates" has length of 0, no data?'
    };
  }

  if (updates.length > 1) {
    _log.default.warn("Only XVIZ first update of \"snapshot\" is currently supported. Current updates has \"".concat(updates.length, "\" entries."))();
  }

  var streamSets = updates;
  var timestamp = null;

  if (!timestamp && streamSets) {
    timestamp = streamSets.reduce(function (t, stateUpdate) {
      return Math.max(t, stateUpdate.timestamp);
    }, 0);
  }

  if (!timestamp) {
    // Incomplete stream message, just tag it accordingly so client can ignore it
    return {
      type: _constants.LOG_STREAM_MESSAGE.INCOMPLETE,
      message: 'Missing timestamp in "updates"'
    };
  }

  var newStreams = {};
  var result = {
    type: _constants.LOG_STREAM_MESSAGE.TIMESLICE,
    streams: newStreams,
    timestamp: timestamp // TODO/Xintong validate primary vehicle pose in each update?

  };

  if (streamSets) {
    var xvizStreams = parseStreamSets(streamSets, timestamp, convertPrimitive);
    Object.assign(newStreams, xvizStreams);
  }

  return result;
}
/* eslint-disable max-statements */


function parseStreamSets(streamSets, timestamp, convertPrimitive) {
  var _getXVIZConfig = (0, _xvizConfig.getXVIZConfig)(),
      STREAM_BLACKLIST = _getXVIZConfig.STREAM_BLACKLIST;

  var newStreams = {};
  var poses = {};
  var primitives = {};
  var variables = {};
  var timeSeries = [];
  var futures = {};
  var uiPrimitives = {};
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = streamSets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var streamSet = _step.value;
      Object.assign(poses, streamSet.poses);
      Object.assign(primitives, streamSet.primitives);
      Object.assign(variables, streamSet.variables);
      Object.assign(futures, streamSet.future_instances);
      Object.assign(uiPrimitives, streamSet.ui_primitives);

      if (streamSet.time_series) {
        if (timeSeries) {
          timeSeries.push.apply(timeSeries, _toConsumableArray(streamSet.time_series));
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  Object.keys(poses).filter(function (streamName) {
    return !STREAM_BLACKLIST.has(streamName);
  }).forEach(function (streamName) {
    newStreams[streamName] = (0, _parseXvizPose.parseXVIZPose)(poses[streamName]);
  });
  Object.keys(primitives).filter(function (streamName) {
    return !STREAM_BLACKLIST.has(streamName);
  }).forEach(function (primitive) {
    newStreams[primitive] = (0, _parseXvizStream.parseStreamPrimitive)(primitives[primitive], primitive, timestamp, convertPrimitive);
  });
  Object.keys(variables).filter(function (streamName) {
    return !STREAM_BLACKLIST.has(streamName);
  }).forEach(function (variable) {
    newStreams[variable] = (0, _parseXvizStream.parseStreamVariable)(variables[variable], variable, timestamp);
  });

  if (timeSeries.length) {
    var timeSeriesStreams = (0, _parseXvizStream.parseStreamTimeSeries)(timeSeries, STREAM_BLACKLIST);
    Object.assign(newStreams, timeSeriesStreams);
  }

  Object.keys(futures).filter(function (streamName) {
    return !STREAM_BLACKLIST.has(streamName);
  }).forEach(function (future) {
    newStreams[future] = (0, _parseXvizStream.parseStreamFutures)(futures[future], future, timestamp, convertPrimitive);
  });
  Object.keys(uiPrimitives).filter(function (streamName) {
    return !STREAM_BLACKLIST.has(streamName);
  }).forEach(function (primitive) {
    newStreams[primitive] = (0, _parseXvizStream.parseStreamUIPrimitives)(uiPrimitives[primitive], primitive, timestamp);
  });
  return newStreams;
}
/* eslint-enable max-statements */
//# sourceMappingURL=parse-timeslice-data-v2.js.map