{"version":3,"sources":["../../../src/synchronizers/xviz-stream-buffer.js"],"names":["LEFT","INSERT_POSITION","RIGHT","UNLIMITED","OFFSET","FIXED","XVIZStreamBuffer","startOffset","endOffset","maxLength","Number","isFinite","bufferType","options","bufferStart","bufferEnd","timeslices","streams","videos","lastUpdate","hasBuffer","bind","start","end","Math","min","_pruneBuffer","oldStart","oldEnd","len","length","timestamp","startIndex","_indexOf","endIndex","slice","result","streamName","filter","value","undefined","map","t","vehiclePose","Boolean","timeslice","isInBufferRange","Array","insertPosition","timesliceAtInsertPosition","_mergeTimesliceAt","_insertTimesliceAt","fromTime","toTime","getLoadedTimeRange","XVIZObject","prune","trimStart","trimEnd","splice","stream","index","Object","assign"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport XVIZObject from '../objects/xviz-object';\nimport assert from '../utils/assert';\nimport {findInsertPos, INSERT_POSITION} from '../utils/search';\n\n// Insert positions\nconst LEFT = INSERT_POSITION.LEFT;\nconst RIGHT = INSERT_POSITION.RIGHT;\n\n// Buffer types\nconst UNLIMITED = 0;\nconst OFFSET = 1;\nconst FIXED = 2;\n\nexport default class XVIZStreamBuffer {\n  /**\n   * constructor\n   * @param {object} options\n   * @param {number} options.startOffset - desired start of buffer to keep in memory\n   *  relative to the current time.\n   * @param {number} options.endOffset - desired end of buffer to keep in memory\n   *  relative to the current time.\n   */\n  constructor({startOffset = null, endOffset = null, maxLength = null} = {}) {\n    if (Number.isFinite(startOffset) && Number.isFinite(endOffset)) {\n      assert(startOffset <= 0 && endOffset >= 0, 'Steam buffer offset');\n      this.bufferType = OFFSET;\n    } else {\n      this.bufferType = UNLIMITED;\n    }\n\n    this.options = {\n      startOffset,\n      endOffset,\n      maxLength\n    };\n\n    /* Desired buffer range, in timestamps */\n    this.bufferStart = null;\n    this.bufferEnd = null;\n    /* Sorted timeslices */\n    this.timeslices = [];\n    /* Sorted values by stream */\n    this.streams = {};\n    this.videos = {};\n    /* Update counter */\n    this.lastUpdate = 0;\n\n    this.hasBuffer = this.hasBuffer.bind(this);\n  }\n\n  /**\n   * @property {number} the count of timeslices in buffer\n   */\n  get size() {\n    return this.timeslices.length;\n  }\n\n  /**\n   * updates the fixed buffer range, capping it to maxLength if set\n   * @param {number} start - desired fixed start time of buffer to keep in memory\n   * @param {number} end - desired fixed end time of buffer to keep in memory\n   * @returns {start: number, end: number, oldStart: number, oldEnd: number} - the old and new buffer ranges\n   */\n  updateFixedBuffer(start, end) {\n    const {\n      bufferStart,\n      bufferEnd,\n      options: {maxLength}\n    } = this;\n    assert(start < end, 'updateFixedBuffer start / end');\n    assert(\n      this.bufferType === UNLIMITED || this.bufferType === FIXED,\n      'updateFixedBuffer multiple buffer types'\n    );\n    this.bufferType = FIXED;\n\n    if (!maxLength) {\n      // If we have no limits on buffer size, just use the new provided values\n      this.bufferStart = start;\n      this.bufferEnd = end;\n    } else if (\n      !Number.isFinite(bufferStart) ||\n      start > bufferEnd + maxLength ||\n      start < bufferStart - maxLength\n    ) {\n      // If we have a limit but this is our first range definition, or this is so far before the existing\n      // buffer that there's no overlap, use the provided start and determine end based on max buffer length\n      this.bufferStart = start;\n      this.bufferEnd = Math.min(end, start + maxLength);\n    } else if (start < bufferStart) {\n      // If this is before the existing buffer but close enough to have overlap, use the provided start\n      // and determine the end based on max buffer length and the existing buffer end\n      this.bufferStart = start;\n      this.bufferEnd = Math.min(bufferEnd, start + maxLength);\n    } else {\n      // Otherwise, we're past the end of the existing buffer and either extend the existing buffer\n      // or start a new buffer based on maxLength\n      this.bufferStart = Math.min(bufferEnd, end - maxLength);\n      this.bufferEnd = Math.min(this.bufferStart + maxLength, end);\n    }\n    this._pruneBuffer();\n    return {start: this.bufferStart, end: this.bufferEnd, oldStart: bufferStart, oldEnd: bufferEnd};\n  }\n\n  /**\n   * Gets the time range that the buffer is accepting data for\n   * @returns {object} - {start | null, end | null} timestamps if any timeslice is loaded\n   */\n  getBufferRange() {\n    if (this.bufferType !== UNLIMITED) {\n      const {bufferStart, bufferEnd} = this;\n      if (Number.isFinite(bufferStart)) {\n        // buffer range should be ignored if setCurrentTime has not been called\n        return {start: bufferStart, end: bufferEnd};\n      }\n    }\n    return {start: null, end: null};\n  }\n\n  /**\n   * Gets the buffered time range\n   * @returns {object | null} - {start, end} timestamps if any timeslice is loaded\n   */\n  getLoadedTimeRange() {\n    const {timeslices} = this;\n    const len = timeslices.length;\n\n    if (len > 0) {\n      return {\n        start: timeslices[0].timestamp,\n        end: timeslices[len - 1].timestamp\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Gets timeslices within a given time range.\n   * @params {number, optional} start - start timestamp (inclusive)\n   * @params {number, optional} end - end timestamp (inclusive)\n   * @returns {array} - loaded timeslices within range\n   */\n  getTimeslices({start, end} = {}) {\n    const {timeslices} = this;\n    const startIndex = Number.isFinite(start) ? this._indexOf(start, LEFT) : 0;\n    const endIndex = Number.isFinite(end) ? this._indexOf(end, RIGHT) : timeslices.length;\n    return timeslices.slice(startIndex, endIndex);\n  }\n\n  /**\n   * Deprecated for perf reasons\n   * Gets loaded stream slices within the current buffer\n   */\n  getStreams() {\n    const {streams} = this;\n    const result = {};\n    for (const streamName in streams) {\n      result[streamName] = streams[streamName].filter(value => value !== undefined);\n    }\n    return result;\n  }\n\n  /**\n   * Gets loaded video frames within the current buffer\n   */\n  getVideos() {\n    const {videos} = this;\n    const result = {};\n    for (const streamName in videos) {\n      result[streamName] = videos[streamName].filter(value => value !== undefined);\n    }\n    return result;\n  }\n\n  /**\n   * Get vehicle poses within the current buffer\n   */\n  getVehiclePoses() {\n    return this.timeslices.map(t => t.vehiclePose).filter(Boolean);\n  }\n\n  /**\n   * Add a new timeslice object into the timeline\n   * @params {object} timeslice - timeslice object from XVIZ stream\n   */\n  insert(timeslice) {\n    const {timestamp} = timeslice;\n\n    if (!this.isInBufferRange(timestamp)) {\n      return false;\n    }\n\n    // backwards compatibility - normalize time slice\n    timeslice.streams = timeslice.streams || {};\n    timeslice.videos = timeslice.videos || {};\n\n    const {timeslices, streams, videos} = this;\n\n    for (const streamName in timeslice.streams) {\n      if (!streams[streamName]) {\n        streams[streamName] = new Array(timeslices.length);\n      }\n    }\n    for (const streamName in timeslice.videos) {\n      if (!videos[streamName]) {\n        videos[streamName] = new Array(timeslices.length);\n      }\n    }\n\n    const insertPosition = this._indexOf(timestamp, LEFT);\n    const timesliceAtInsertPosition = timeslices[insertPosition];\n\n    if (timesliceAtInsertPosition && timesliceAtInsertPosition.timestamp === timestamp) {\n      // Same timestamp, needs a merge\n      this._mergeTimesliceAt(insertPosition, timeslice);\n    } else {\n      this._insertTimesliceAt(insertPosition, timeslice);\n    }\n\n    this.lastUpdate++;\n    return true;\n  }\n\n  /**\n   * Set the current timestamp\n   * May drop timeslices that are not in range\n   * @params {number} timestamp - timestamp of the playhead\n   */\n  setCurrentTime(timestamp) {\n    if (this.bufferType === OFFSET) {\n      const {\n        options: {startOffset, endOffset}\n      } = this;\n      this.bufferStart = timestamp + startOffset;\n      this.bufferEnd = timestamp + endOffset;\n      this._pruneBuffer();\n    }\n  }\n\n  /**\n   * Override Object.prototype.valueOf\n   * This is used to trigger a selector update without creating a new XVIZStreamBuffer instance\n   */\n  valueOf() {\n    return this.lastUpdate;\n  }\n\n  /**\n   * Provide interface for video-synchronizer to test for valid gps-based time range data.\n   *\n   * @params {number} fromTime is the gps time start of data\n   * @params {number} toTime is the gps time end of data\n   * @returns {bool} If we have no data, always return true, else true is returned\n   *                 if the time range is satisfied\n   */\n  hasBuffer(fromTime, toTime) {\n    if (!this.timeslices.length) {\n      return true;\n    }\n    const {start, end} = this.getLoadedTimeRange();\n    return fromTime >= start && toTime <= end;\n  }\n\n  /**\n   * Check if a timestamp is inside the desired buffer range\n   * @params {number} timestamp\n   * @returns {bool}\n   */\n  isInBufferRange(timestamp) {\n    const {bufferStart, bufferEnd, bufferType} = this;\n    if (bufferType !== UNLIMITED && Number.isFinite(bufferStart)) {\n      return timestamp >= bufferStart && timestamp <= bufferEnd;\n    }\n    return true;\n  }\n\n  /* eslint-disable complexity, no-unused-expressions */\n  _pruneBuffer() {\n    const {timeslices, streams, videos} = this;\n\n    if (timeslices.length) {\n      const startIndex = this._indexOf(this.bufferStart, LEFT);\n      const endIndex = this._indexOf(this.bufferEnd, RIGHT);\n\n      XVIZObject.prune(this.bufferStart, this.bufferEnd);\n\n      const trimStart = startIndex > 0;\n      const trimEnd = endIndex < timeslices.length;\n      if (trimStart || trimEnd) {\n        // Drop frames that are outside of the buffer\n        trimEnd && timeslices.splice(endIndex);\n        trimStart && timeslices.splice(0, startIndex);\n\n        for (const streamName in streams) {\n          const stream = streams[streamName];\n          trimEnd && stream.splice(endIndex);\n          trimStart && stream.splice(0, startIndex);\n        }\n        for (const streamName in videos) {\n          const stream = videos[streamName];\n          trimEnd && stream.splice(endIndex);\n          trimStart && stream.splice(0, startIndex);\n        }\n\n        this.lastUpdate++;\n      }\n    }\n  }\n  /* eslint-enable complexity, no-unused-expressions */\n\n  _mergeTimesliceAt(index, timeslice) {\n    const {timeslices, streams, videos} = this;\n    const timesliceAtInsertPosition = timeslices[index];\n\n    Object.assign(timesliceAtInsertPosition, timeslice, {\n      streams: Object.assign(timesliceAtInsertPosition.streams, timeslice.streams),\n      videos: Object.assign(timesliceAtInsertPosition.videos, timeslice.videos)\n    });\n\n    for (const streamName in timeslice.streams) {\n      streams[streamName][index] = timeslice.streams[streamName];\n    }\n    for (const streamName in timeslice.videos) {\n      videos[streamName][index] = timeslice.videos[streamName];\n    }\n  }\n\n  _insertTimesliceAt(index, timeslice) {\n    const {timeslices, streams, videos} = this;\n\n    timeslices.splice(index, 0, timeslice);\n\n    for (const streamName in streams) {\n      streams[streamName].splice(index, 0, timeslice.streams[streamName]);\n    }\n    for (const streamName in videos) {\n      videos[streamName].splice(index, 0, timeslice.videos[streamName]);\n    }\n  }\n\n  /**\n   * Return insert position for timeslice data given a timestamp\n   * @params {number} timestamp\n   * @params {number} insertPosition - insert to the left or right of the equal element.\n   * @returns {number} index of insert position\n   */\n  _indexOf(timestamp, insertPosition = LEFT) {\n    const {timeslices} = this;\n    return findInsertPos(timeslices, timestamp, insertPosition);\n  }\n}\n"],"file":"xviz-stream-buffer.js"}