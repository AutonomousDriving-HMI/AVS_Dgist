"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _parser = require("@xviz/parser");

var _math = require("math.gl");

var _metricsHelper = require("../utils/metrics-helper");

var _createSelector = _interopRequireDefault(require("../utils/create-selector"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable callback-return */
var XVIZLoaderInterface =
/*#__PURE__*/
function () {
  function XVIZLoaderInterface() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, XVIZLoaderInterface);

    _defineProperty(this, "getCurrentTime", function () {
      return _this.get('timestamp');
    });

    _defineProperty(this, "getLookAhead", function () {
      return _this.get('lookAhead');
    });

    _defineProperty(this, "getMetadata", function () {
      return _this.get('metadata');
    });

    _defineProperty(this, "getStreamSettings", function () {
      return _this.get('streamSettings');
    });

    _defineProperty(this, "getLogSynchronizer", function () {
      return _this.get('logSynchronizer');
    });

    _defineProperty(this, "_getStreams", function () {
      return _this.get('streams');
    });

    _defineProperty(this, "getStreams", (0, _createSelector.default)(this, [this.getStreamSettings, this._getStreams], function (streamSettings, streams) {
      if (!streamSettings || !streams) {
        return streams;
      }

      var result = {};

      for (var streamName in streams) {
        if (streamSettings[streamName]) {
          result[streamName] = streams[streamName];
        }
      }

      return result;
    }));

    _defineProperty(this, "getLogStartTime", (0, _createSelector.default)(this, this.getMetadata, function (metadata) {
      return metadata && metadata.start_time && metadata.start_time + (0, _parser.getXVIZConfig)().TIME_WINDOW;
    }));

    _defineProperty(this, "getLogEndTime", (0, _createSelector.default)(this, this.getMetadata, function (metadata) {
      return metadata && metadata.end_time;
    }));

    _defineProperty(this, "getCurrentFrame", (0, _createSelector.default)(this, [this.getLogSynchronizer, this.getStreamSettings, this.getCurrentTime, this.getLookAhead, this.getStreams], // `getStreams` is only needed to trigger recomputation.
    // The logSynchronizer has access to the streamBuffer.
    function (logSynchronizer, streamSettings, timestamp, lookAhead) {
      if (logSynchronizer && Number.isFinite(timestamp)) {
        logSynchronizer.setTime(timestamp);
        logSynchronizer.setLookAheadTimeOffset(lookAhead);
        return logSynchronizer.getCurrentFrame(streamSettings);
      }

      return null;
    }));

    _defineProperty(this, "getTimeSeries", (0, _createSelector.default)(this, [this.getMetadata, this.getStreams], function (metadata, streams) {
      return (0, _metricsHelper.getTimeSeries)({
        metadata: metadata,
        streams: streams
      });
    }));

    _defineProperty(this, "_update", function () {
      _this._updateTimer = null;

      _this.listeners.forEach(function (o) {
        return o(_this._version);
      });
    });

    this.options = options;

    this._debug = options.debug || function () {};

    this.callbacks = {};
    this.listeners = [];
    this.state = {};
    this._version = 0;
    this._updateTimer = null;
  }
  /* Event types:
   * - ready
   * - update
   * - finish
   * - error
   */


  _createClass(XVIZLoaderInterface, [{
    key: "on",
    value: function on(eventType, cb) {
      this.callbacks[eventType] = this.callbacks[eventType] || [];
      this.callbacks[eventType].push(cb);
      return this;
    }
  }, {
    key: "off",
    value: function off(eventType, cb) {
      var callbacks = this.callbacks[eventType];

      if (callbacks) {
        var index = callbacks.indexOf(cb);

        if (index >= 0) {
          callbacks.splice(index, 1);
        }
      }

      return this;
    }
  }, {
    key: "emit",
    value: function emit(eventType, eventArgs) {
      var callbacks = this.callbacks[eventType];

      if (callbacks) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = callbacks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var cb = _step.value;
            cb(eventType, eventArgs);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }
  }, {
    key: "subscribe",
    value: function subscribe(instance) {
      this.listeners.push(instance);
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(instance) {
      var index = this.listeners.findIndex(function (o) {
        return o === instance;
      });

      if (index >= 0) {
        this.listeners.splice(index, 1);
      }
    }
  }, {
    key: "get",
    value: function get(key) {
      return this.state[key];
    }
  }, {
    key: "set",
    value: function set(key, value) {
      if (this.state[key] !== value) {
        this.state[key] = value;
        this._version++;

        if (!this._updateTimer) {
          /* global requestAnimationFrame */
          this._updateTimer = requestAnimationFrame(this._update);
        }
      }
    }
    /* Connection API */

  }, {
    key: "isOpen",
    value: function isOpen() {
      return false;
    }
  }, {
    key: "connect",
    value: function connect() {
      throw new Error('not implemented');
    }
  }, {
    key: "seek",
    value: function seek(timestamp) {
      var metadata = this.getMetadata();

      if (metadata) {
        var startTime = this.getLogStartTime();
        var endTime = this.getLogEndTime();

        if (Number.isFinite(startTime) && Number.isFinite(endTime)) {
          timestamp = (0, _math.clamp)(timestamp, startTime, endTime);
        }
      }

      this.set('timestamp', timestamp);
    }
  }, {
    key: "setLookAhead",
    value: function setLookAhead(lookAhead) {
      this.set('lookAhead', lookAhead);
    }
  }, {
    key: "updateStreamSettings",
    value: function updateStreamSettings(settings) {
      var streamSettings = this.get('streamSettings');
      this.set('streamSettings', _objectSpread({}, streamSettings, settings));
    }
  }, {
    key: "close",
    value: function close() {
      throw new Error('not implemented');
    }
    /* Data selector API */

  }, {
    key: "getBufferRange",
    value: function getBufferRange() {
      throw new Error('not implemented');
    }
  }, {
    key: "getBufferStart",
    value: function getBufferStart() {
      return this.getLogStartTime();
    }
  }, {
    key: "getBufferEnd",
    value: function getBufferEnd() {
      return this.getLogEndTime();
    }
  }, {
    key: "_setMetadata",
    value: function _setMetadata(metadata) {
      this.set('metadata', metadata);

      if (metadata.streams && Object.keys(metadata.streams).length > 0) {
        this.set('streamSettings', metadata.streams);
      }

      var timestamp = this.get('timestamp');
      var newTimestamp = Number.isFinite(timestamp) ? timestamp : metadata.start_time;

      if (Number.isFinite(newTimestamp)) {
        this.seek(newTimestamp);
      }
    }
  }]);

  return XVIZLoaderInterface;
}();

exports.default = XVIZLoaderInterface;
//# sourceMappingURL=xviz-loader-interface.js.map