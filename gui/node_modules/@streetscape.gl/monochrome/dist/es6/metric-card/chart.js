function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import AutoSizer from '../shared/autosizer';
import XYPlot from 'react-vis/dist/plot/xy-plot';
import AreaSeries from 'react-vis/dist/plot/series/area-series';
import LineSeries from 'react-vis/dist/plot/series/line-series';
import MarkSeries from 'react-vis/dist/plot/series/mark-series';
import HorizontalGridLines from 'react-vis/dist/plot/horizontal-grid-lines';
import VerticalGridLines from 'react-vis/dist/plot/vertical-grid-lines';
import XAxis from 'react-vis/dist/plot/axis/x-axis';
import YAxis from 'react-vis/dist/plot/axis/y-axis';
import Crosshair from 'react-vis/dist/plot/crosshair';
import { scaleLinear } from 'd3-scale';
import { withTheme } from '../shared/theme';
import { ChartContainer, CrosshairItemTitle, CrosshairItemLegend, CrosshairItemValue } from './styled-components';

const noop = () => {};

const DEFAULT_MARGIN = {
  left: 32,
  right: 20,
  top: 20,
  bottom: 32
};
/**
 * A metric chart draws a chart with optional percentiles and lags
 */

class Chart extends PureComponent {
  /* eslint-disable max-depth, complexity */
  _getScaleSettings() {
    const _this$props = this.props,
          data = _this$props.data,
          dataFilter = _this$props.dataFilter,
          xDomain = _this$props.xDomain,
          yDomain = _this$props.yDomain,
          getX = _this$props.getX,
          getY0 = _this$props.getY0,
          getY = _this$props.getY;

    if (xDomain && yDomain) {
      return {
        xDomain,
        yDomain
      };
    }

    let x = xDomain || [Infinity, -Infinity];
    let y = yDomain || [0, 0];

    for (const key in data) {
      if (dataFilter(key)) {
        const values = data[key];

        if (Array.isArray(values) && values.length > 0) {
          x = xDomain || values.reduce((acc, d) => {
            const x0 = getX(d);
            acc[0] = Math.min(acc[0], x0);
            acc[1] = Math.max(acc[1], x0);
            return acc;
          }, x);
          y = yDomain || values.reduce((acc, d) => {
            const y1 = getY(d);
            const y0 = getY0(d);
            acc[0] = Math.min(acc[0], y1);
            acc[1] = Math.max(acc[1], y1);

            if (Number.isFinite(y0)) {
              acc[0] = Math.min(acc[0], y0);
              acc[1] = Math.max(acc[1], y0);
            }

            return acc;
          }, y);
        }
      }
    }

    if (!yDomain) {
      // Snap the bounds to nice round numbers
      y = scaleLinear().domain(y).nice().domain();
    }

    return {
      xDomain: x,
      yDomain: y
    };
  }
  /* eslint-enable max-depth, complexity */


  _getColor(key) {
    const getColor = this.props.getColor;

    switch (typeof getColor) {
      case 'object':
        return getColor[key];

      case 'function':
        return getColor(key);

      default:
        return getColor;
    }
  } // Populate series


  _renderSeries() {
    const _this$props2 = this.props,
          data = _this$props2.data,
          dataFilter = _this$props2.dataFilter,
          highlightSeries = _this$props2.highlightSeries,
          getX = _this$props2.getX,
          getY0 = _this$props2.getY0,
          getY = _this$props2.getY,
          xDomain = _this$props2.xDomain;
    const areas = [];
    const lines = [];
    Object.keys(data).forEach(key => {
      if (!dataFilter(key)) {
        return;
      } // Temporary patch until vis-gl fixes issue with rendering data outside of domain
      // https://github.com/uber/react-vis/issues/627


      const datums = xDomain ? data[key].filter(point => {
        const x = getX(point);
        return x >= xDomain[0] && x <= xDomain[1];
      }) : data[key];

      if (!datums.length) {
        return;
      }

      const isArea = Number.isFinite(getY0(datums[0]));
      const Type = isArea ? AreaSeries : LineSeries;

      const color = this._getColor(key);

      const series = React.createElement(Type, {
        key: `value-${key}-line`,
        data: datums,
        getX: getX,
        getY: getY,
        getY0: getY0,
        color: color,
        fill: color,
        strokeWidth: highlightSeries === key ? 4 : 2,
        onNearestX: this.props.onNearestX.bind(this, key),
        onSeriesMouseOver: () => this.props.onSeriesMouseOver(key),
        onSeriesMouseOut: () => this.props.onSeriesMouseOut(key)
      });

      if (isArea) {
        areas.push(series);
      } else {
        lines.push(series);
      }
    }); // Render lines on top

    return areas.concat(lines);
  }

  _renderCrosshair() {
    const highlightValues = this.props.highlightValues;

    if (!highlightValues) {
      return null;
    }

    const _this$props3 = this.props,
          theme = _this$props3.theme,
          style = _this$props3.style,
          unit = _this$props3.unit,
          dataFilter = _this$props3.dataFilter,
          formatTitle = _this$props3.formatTitle,
          formatValue = _this$props3.formatValue,
          getX = _this$props3.getX,
          getY = _this$props3.getY,
          getY0 = _this$props3.getY0,
          xDomain = _this$props3.xDomain;
    const keys = Object.keys(highlightValues).filter(key => {
      const value = highlightValues[key];
      const x = getX(value);
      return dataFilter(key) && (!xDomain || x >= xDomain[0] && x <= xDomain[1]);
    });
    const crosshairItems = keys.map((key, i) => {
      const value = highlightValues[key];

      const color = this._getColor(key);

      const x = getX(value);
      const y = getY(value);
      const y0 = getY0(value);
      const styleProps = {
        theme,
        name: key,
        displayName: formatTitle(key),
        color,
        isFirst: i === 0,
        isLast: i === keys.length - 1
      };
      return {
        x,
        y,
        title: React.createElement(CrosshairItemTitle, _extends({}, styleProps, {
          userStyle: style.crosshairTitle
        }), React.createElement(CrosshairItemLegend, _extends({}, styleProps, {
          userStyle: style.crosshairLegend
        })), styleProps.displayName),
        value: React.createElement(CrosshairItemValue, _extends({}, styleProps, {
          userStyle: style.crosshairValue
        }), Number.isFinite(y0) && `${formatValue(y0)}, `, formatValue(y), unit && React.createElement("span", null, unit)),
        color
      };
    });
    return [React.createElement(Crosshair, {
      key: "crosshair",
      values: crosshairItems,
      titleFormat: () => null,
      itemsFormat: values => values
    }), React.createElement(MarkSeries, {
      key: "hovered-values",
      data: crosshairItems,
      stroke: "#fff",
      strokeWidth: 2,
      getFill: d => d.color,
      fillType: "literal"
    })];
  }

  render() {
    const _this$props4 = this.props,
          theme = _this$props4.theme,
          width = _this$props4.width,
          height = _this$props4.height,
          style = _this$props4.style,
          formatYTick = _this$props4.formatYTick,
          formatXTick = _this$props4.formatXTick,
          xTicks = _this$props4.xTicks,
          yTicks = _this$props4.yTicks,
          horizontalGridLines = _this$props4.horizontalGridLines,
          verticalGridLines = _this$props4.verticalGridLines,
          onMouseEnter = _this$props4.onMouseEnter,
          onMouseMove = _this$props4.onMouseMove,
          onMouseLeave = _this$props4.onMouseLeave,
          onClick = _this$props4.onClick;
    return React.createElement(ChartContainer, {
      theme: theme,
      userStyle: style.chart,
      tooltipStyle: style.crosshair,
      style: {
        width,
        height
      }
    }, React.createElement(AutoSizer, null, (_ref) => {
      let chartWidth = _ref.width,
          chartHeight = _ref.height;
      return React.createElement(XYPlot, _extends({
        width: chartWidth,
        height: chartHeight,
        margin: style.margin || DEFAULT_MARGIN
      }, this._getScaleSettings(), {
        onClick: onClick,
        onMouseEnter: onMouseEnter,
        onMouseMove: onMouseMove,
        onMouseLeave: onMouseLeave
      }), xTicks > 0 && React.createElement(XAxis, {
        title: "",
        tickFormat: formatXTick,
        tickTotal: xTicks
      }), yTicks > 0 && React.createElement(YAxis, {
        title: "",
        tickFormat: formatYTick,
        tickTotal: yTicks
      }), horizontalGridLines > 0 && React.createElement(HorizontalGridLines, {
        tickTotal: horizontalGridLines
      }), verticalGridLines > 0 && React.createElement(VerticalGridLines, {
        tickTotal: verticalGridLines
      }), this._renderSeries(), this._renderCrosshair());
    }));
  }

}

_defineProperty(Chart, "propTypes", {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  style: PropTypes.object,
  unit: PropTypes.string,
  data: PropTypes.object,
  dataFilter: PropTypes.func,
  onClick: PropTypes.func,
  onMouseEnter: PropTypes.func,
  onMouseMove: PropTypes.func,
  onMouseLeave: PropTypes.func,
  onNearestX: PropTypes.func,
  onSeriesMouseOver: PropTypes.func,
  onSeriesMouseOut: PropTypes.func,
  getX: PropTypes.func,
  getY0: PropTypes.func,
  getY: PropTypes.func,
  xDomain: PropTypes.array,
  yDomain: PropTypes.array,
  xTicks: PropTypes.number,
  yTicks: PropTypes.number,
  horizontalGridLines: PropTypes.number,
  verticalGridLines: PropTypes.number,
  highlightSeries: PropTypes.string,
  highlightValues: PropTypes.object,
  formatYTick: PropTypes.func,
  formatTitle: PropTypes.func,
  formatValue: PropTypes.func,
  formatXTick: PropTypes.func,
  getColor: PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.func])
});

_defineProperty(Chart, "defaultProps", {
  width: '100%',
  height: 300,
  style: {},
  data: {},
  dataFilter: key => true,
  unit: '',
  onClick: noop,
  onMouseEnter: noop,
  onMouseMove: noop,
  onMouseLeave: noop,
  onNearestX: noop,
  onSeriesMouseOver: noop,
  onSeriesMouseOut: noop,
  getX: d => d.x,
  getY0: d => null,
  getY: d => d.y,
  // Backward compatibility
  xTicks: 4,
  yTicks: 4,
  horizontalGridLines: 4,
  verticalGridLines: 4,
  formatTitle: value => String(value),
  formatValue: value => String(value),
  formatXTick: value => String(value),
  formatYTick: value => String(value),
  getColor: '#000'
});

export default withTheme(Chart);
//# sourceMappingURL=chart.js.map