{"version":3,"sources":["../../../../src/builders/helpers/xviz-trajectory-helper.js"],"names":["getRelativeCoordinates","vertices","basePose","Pose","transformMatrix","getTransformationMatrix","map","p","transformVector","getPoseTrajectory","poses","startFrame","endFrame","iterationLimit","Math","min","length","i","push","pose","m","getGeospatialVector","yaw","getGeospatialToPoseTransform","from","to","toPose","x","y","z","pitch","roll","v","fromPose","getTransformationMatrixToPose","getObjectTrajectory","targetObject","objectFrames","poseFrames","startVehiclePose","limit","lastFrame","motions","getObjectMotions","step","currVehiclePose","getTransformationMatrixFromPose","heading","fromCoord","turf","point","longitude","latitude","toCoord","distInMeters","distance","units","bearing","relativeBearing","degreesToRadians","radianDiff","cos","sin","getFrameObjects","frames","frameNumber","Map","get","Array","max","firstFrame","objects","object","find","obj","id"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {_Pose as Pose} from 'math.gl';\nimport * as turf from '@turf/turf';\n\n/**\n * Given vertices and a base pose, transform the vertices to `basePose` relative coordinates\n * @param vertices {Array} list of [x, y, z] or [x, y]\n * @param basePose {Object} {x, y, z, longitude, latitude, altitude, roll, pitch, yaw}\n * @returns {Array} list of vertices in relative coordinates\n */\nexport function getRelativeCoordinates(vertices, basePose) {\n  if (!(basePose instanceof Pose)) {\n    basePose = new Pose(basePose);\n  }\n\n  const transformMatrix = basePose.getTransformationMatrix();\n  return vertices.map(p => transformMatrix.transformVector(p));\n}\n\n/**\n * Generate trajectory for list of poses with given start frame and end frame\n * @param poses {Array}, frames of pose data,\n *   each frame contains a `pose` entry with {x, y, z, longitude, latitude, altitude, roll, pitch, yaw}\n * @param startFrame {Number}, start frame of trajectory\n * @param endFrame {Number}, end frame of trajectory\n * @returns {Array} trajectory, list of vertices\n */\nexport function getPoseTrajectory({poses, startFrame, endFrame}) {\n  const vertices = [];\n  const iterationLimit = Math.min(endFrame, poses.length);\n\n  for (let i = startFrame; i < iterationLimit; i++) {\n    vertices.push(poses[i].pose);\n  }\n\n  return vertices.map((m, i) => getGeospatialVector(vertices[0], m, vertices[0].yaw));\n}\n\n/**\n * Return transform matrix that can be used to transform\n * data in futurePose into the currentPose reference frame\n *\n * @param from {Object} {longitude, latitude, pitch, roll, yaw}\n * @param to {Object} {longitude, latitude, pitch, roll, yaw}\n * @returns {Object} tranformation matrix that converts 'from' relative coordinates into 'to' relative coordinates\n */\nexport function getGeospatialToPoseTransform(from, to) {\n  const toPose = new Pose({\n    x: 0,\n    y: 0,\n    z: 0,\n    pitch: to.pitch,\n    roll: to.roll,\n    yaw: to.yaw\n  });\n\n  // Since 'to' is the target, get the vector from 'to -> from'\n  // and use that to set the position of 'from Pose'\n  const v = getGeospatialVector(to, from, to.yaw);\n\n  const fromPose = new Pose({\n    x: v[0],\n    y: v[1],\n    z: 0,\n    pitch: from.pitch,\n    roll: from.roll,\n    yaw: from.yaw\n  });\n\n  return toPose.getTransformationMatrixToPose(fromPose);\n}\n\n/**\n * Get object trajectory in pose relative coordinates\n * @param targetObject {Object} {id, x, y, z, ...}\n * @param objectFrames {Array}, all the frames of objects, (object: {id, x, y, z})\n * @param poseFrames {Array}, all the frames of base poses (pose: {longitude, latitude, altitude})\n * @param startFrame {Number}, start frame of trajectory\n * @param endFrame {Number}, end frame of trajectory\n * @returns {Array} trajectory, list of vertices\n */\nexport function getObjectTrajectory({\n  targetObject,\n  objectFrames,\n  poseFrames,\n  startFrame,\n  endFrame\n}) {\n  const vertices = [];\n  const startVehiclePose = poseFrames[startFrame].pose;\n  const limit = Math.min(endFrame, targetObject.lastFrame);\n  const motions = getObjectMotions(targetObject, objectFrames, startFrame, limit);\n\n  for (let i = 0; i < motions.length; i++) {\n    const step = motions[i];\n    const currVehiclePose = poseFrames[startFrame + i].pose;\n\n    const [x, y] = getGeospatialVector(startVehiclePose, currVehiclePose, startVehiclePose.yaw);\n\n    const transformMatrix = new Pose(currVehiclePose).getTransformationMatrixFromPose(\n      new Pose(startVehiclePose)\n    );\n\n    // objects in curr frame are meters offset based on current vehicle pose\n    // need to convert to the coordinate system of the start vehicle pose\n    const p = transformMatrix.transformVector([step.x, step.y, step.z]);\n    vertices.push([p[0] + x, p[1] + y, p[2]]);\n  }\n\n  return vertices;\n}\n\n/**\n * Get the meter vector from geospatial coordinates relative to the given heading\n *\n * @param from {Object} {longitude, latitude}\n * @param to {Object} {longitude, latitude}\n * @param heading {Number} Radian measurement, 0 = east, positive is counter clockwise\n * @returns {Array} Vector [x, y] in meters\n */\nexport function getGeospatialVector(from, to, heading = 0) {\n  const fromCoord = turf.point([from.longitude, from.latitude]);\n  const toCoord = turf.point([to.longitude, to.latitude]);\n  const distInMeters = turf.distance(fromCoord, toCoord, {units: 'meters'});\n\n  // Bearing is degrees from north, positive is clockwise\n  const bearing = turf.bearing(fromCoord, toCoord);\n\n  // Get the bearing relative to heading\n  const relativeBearing = turf.degreesToRadians(90 - bearing);\n  const radianDiff = relativeBearing - heading;\n\n  return [distInMeters * Math.cos(radianDiff), distInMeters * Math.sin(radianDiff)];\n}\n\nfunction getFrameObjects(frames, frameNumber) {\n  if (frames instanceof Map) {\n    return frames.get(frameNumber);\n  }\n  if (frames instanceof Array) {\n    return frames[frameNumber];\n  }\n  return null;\n}\n\n/**\n * Generate motions for target object\n * @param targetObject {Object} {startFrame, endFrame, id, x, y, z,...}\n * @param objectFrames {Map | Array}, either a Map (key is frameNumber, value is list of objects) or an array of frames\n * @param startFrame {Number}\n * @param endFrame {Number}\n * @returns {Array} list of motions from given startFrame to endFrame\n */\nfunction getObjectMotions(targetObject, objectFrames, startFrame, endFrame) {\n  startFrame = Math.max(targetObject.firstFrame, startFrame);\n  endFrame = Math.min(targetObject.lastFrame, endFrame);\n\n  const motions = [];\n  for (let i = startFrame; i < endFrame; i++) {\n    const objects = getFrameObjects(objectFrames, i);\n    const object = objects.find(obj => obj.id === targetObject.id);\n    motions.push(object);\n  }\n\n  return motions;\n}\n"],"file":"xviz-trajectory-helper.js"}