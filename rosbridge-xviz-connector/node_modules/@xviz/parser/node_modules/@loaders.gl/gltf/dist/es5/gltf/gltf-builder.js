"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _glbBuilder = _interopRequireDefault(require("../glb/glb-builder"));

var _packBinaryJson = _interopRequireDefault(require("../packed-json/pack-binary-json"));

var _core = require("@loaders.gl/core");

/* eslint-disable camelcase, max-statements */
// Ideally we should just use KHR_draco_mesh_compression, but it requires saving uncompressed data?
// TODO: until the ideal, we need to export these
var UBER_MESH_EXTENSION = 'UBER_draco_mesh_compression';
var UBER_POINT_CLOUD_EXTENSION = 'UBER_draco_point_cloud_compression';

var GLTFBuilder =
/*#__PURE__*/
function (_GLBBuilder) {
  (0, _inherits2.default)(GLTFBuilder, _GLBBuilder);

  function GLTFBuilder() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, GLTFBuilder);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(GLTFBuilder).call(this, options)); // Soft dependency on DRACO, app needs to import and supply these

    _this.DracoEncoder = options.DracoEncoder;
    _this.DracoDecoder = options.DracoDecoder;
    Object.assign(_this.json, {
      meshes: []
    });
    return _this;
  } // TODO - support encoding to non-GLB versions of glTF format
  // Encode as a textual JSON file with binary data in base64 data URLs.
  // encodeAsDataURLs(options) {
  //   throw new Error('Not yet implemented');
  // }
  // Encode as a JSON with all images (and buffers?) in separate binary files
  // encodeAsSeparateFiles(options) {
  //   throw new Error('Not yet imlemented');
  // }
  // Add an extra application-defined key to the top-level data structure
  // By default packs JSON by extracting binary data and replacing it with JSON pointers


  (0, _createClass2.default)(GLTFBuilder, [{
    key: "addApplicationData",
    value: function addApplicationData(key, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var jsonData = packOptions.nopack ? data : (0, _packBinaryJson.default)(data, this, packOptions);
      this.json[key] = jsonData;
      return this;
    } // `extras` - Standard GLTF field for storing application specific data
    // By default packs JSON by extracting binary data and replacing it with JSON pointers

  }, {
    key: "addExtraData",
    value: function addExtraData(key, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var packedJson = !packOptions.nopack && (0, _packBinaryJson.default)(data, this, packOptions);
      this.json.extras = this.json.extras || {};
      this.json.extras[key] = packedJson;
      return this;
    } // Add to standard GLTF top level extension object, mark as used
    // By default packs JSON by extracting binary data and replacing it with JSON pointers

  }, {
    key: "addExtension",
    value: function addExtension(extensionName, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      (0, _core.assert)(data);
      var packedJson = !packOptions.nopack && (0, _packBinaryJson.default)(data, this, packOptions);
      this.json.extensions = this.json.extensions || {};
      this.json.extensions[extensionName] = packedJson;
      this.registerUsedExtension(extensionName);
      return this;
    } // Standard GLTF top level extension object, mark as used and required
    // By default packs JSON by extracting binary data and replacing it with JSON pointers

  }, {
    key: "addRequiredExtension",
    value: function addRequiredExtension(extensionName, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      (0, _core.assert)(data);
      var packedJson = !packOptions.nopack && (0, _packBinaryJson.default)(data, this, packOptions);
      this.addExtension(extensionName, packedJson);
      this.registerRequiredExtension(extensionName);
      return this;
    } // Add extensionName to list of used extensions

  }, {
    key: "registerUsedExtension",
    value: function registerUsedExtension(extensionName) {
      this.json.extensionsUsed = this.json.extensionsUsed || [];

      if (!this.json.extensionsUsed.find(function (ext) {
        return ext === extensionName;
      })) {
        this.json.extensionsUsed.push(extensionName);
      }
    } // Add extensionName to list of required extensions

  }, {
    key: "registerRequiredExtension",
    value: function registerRequiredExtension(extensionName) {
      this.registerUsedExtension(extensionName);
      this.json.extensionsRequired = this.json.extensionsRequired || [];

      if (!this.json.extensionsRequired.find(function (ext) {
        return ext === extensionName;
      })) {
        this.json.extensionsRequired.push(extensionName);
      }
    } // POINTS:  0x0000,
    // LINES: 0x0001,
    // LINE_LOOP: 0x0002,
    // LINE_STRIP:  0x0003,
    // TRIANGLES: 0x0004,
    // TRIANGLE_STRIP:  0x0005,
    // TRIANGLE_FAN:  0x0006,

  }, {
    key: "addMesh",
    value: function addMesh(attributes, indices) {
      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

      var accessors = this._addAttributes(attributes);

      var glTFMesh = {
        primitives: [{
          attributes: accessors,
          indices: indices,
          mode: mode
        }]
      };
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
  }, {
    key: "addPointCloud",
    value: function addPointCloud(attributes) {
      var accessorIndices = this._addAttributes(attributes);

      var glTFMesh = {
        primitives: [{
          attributes: accessorIndices,
          mode: 0 // GL.POINTS

        }]
      };
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    } // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/
    //   KHR_draco_mesh_compression
    // NOTE: in contrast to glTF spec, does not add fallback data

  }, {
    key: "addCompressedMesh",
    value: function addCompressedMesh(attributes, indices) {
      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

      if (!this.DracoEncoder || !this.DracoDecoder) {
        throw new Error('DracoEncoder/Decoder not available');
      }

      var dracoEncoder = new this.DracoEncoder();
      var compressedData = dracoEncoder.encodeMesh(attributes); // Draco compression may change the order and number of vertices in a mesh.
      // To satisfy the requirement that accessors properties be correct for both
      // compressed and uncompressed data, generators should create uncompressed
      // attributes and indices using data that has been decompressed from the Draco buffer,
      // rather than the original source data.

      var dracoDecoder = new this.DracoDecoder();
      var decodedData = dracoDecoder.decodeMesh(attributes);

      var fauxAccessors = this._addFauxAttributes(decodedData.attributes);

      var bufferViewIndex = this.addBufferView(compressedData);
      var glTFMesh = {
        primitives: [{
          attributes: fauxAccessors,
          mode: mode,
          // GL.POINTS
          extensions: (0, _defineProperty2.default)({}, UBER_MESH_EXTENSION, {
            bufferView: bufferViewIndex
          })
        }]
      };
      this.registerRequiredExtension(UBER_MESH_EXTENSION);
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
  }, {
    key: "addCompressedPointCloud",
    value: function addCompressedPointCloud(attributes) {
      if (!this.DracoEncoder || !this.DracoDecoder) {
        throw new Error('DracoEncoder/Decoder not available');
      }

      var dracoEncoder = new this.DracoEncoder();
      var compressedData = dracoEncoder.encodePointCloud(attributes);
      var bufferViewIndex = this.addBufferView(compressedData);
      var glTFMesh = {
        primitives: [{
          attributes: {},
          // This will be populated after decompression
          mode: 0,
          // GL.POINTS
          extensions: (0, _defineProperty2.default)({}, UBER_POINT_CLOUD_EXTENSION, {
            bufferView: bufferViewIndex
          })
        }]
      };
      this.registerRequiredExtension(UBER_POINT_CLOUD_EXTENSION);
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    } // Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
    // Buffer will be copied into BIN chunk during "pack"
    // Currently encodes as glTF image

  }, {
    key: "addImage",
    value: function addImage(imageData) {
      var bufferViewIndex = this.addBufferView(imageData); // Get the properties of the image to add as metadata.

      var sizeAndType = (0, _core.getImageSize)(imageData) || {};

      if (sizeAndType) {
        // width and height are non-spec fields
        var mimeType = sizeAndType.mimeType,
            width = sizeAndType.width,
            height = sizeAndType.height;
        this.json.images.push({
          bufferView: bufferViewIndex,
          mimeType: mimeType,
          width: width,
          height: height
        });
      } else {
        // TODO: Spec violation, if we are using a bufferView, mimeType must be defined
        //       https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images
        //       "a reference to a bufferView; in that case mimeType must be defined."
        this.json.images.push({
          bufferView: bufferViewIndex
        });
      }

      return this.json.images.length - 1;
    }
  }]);
  return GLTFBuilder;
}(_glbBuilder.default);

exports.default = GLTFBuilder;
//# sourceMappingURL=gltf-builder.js.map