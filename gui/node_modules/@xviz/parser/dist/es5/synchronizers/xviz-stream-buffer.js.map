{"version":3,"sources":["../../../src/synchronizers/xviz-stream-buffer.js"],"names":["LEFT","INSERT_POSITION","RIGHT","UNLIMITED","OFFSET","FIXED","XVIZStreamBuffer","startOffset","endOffset","maxLength","Number","isFinite","bufferType","options","bufferStart","bufferEnd","timeslices","streams","videos","lastUpdate","hasBuffer","bind","start","end","Math","min","_pruneBuffer","oldStart","oldEnd","len","length","timestamp","startIndex","_indexOf","endIndex","slice","map","t","vehiclePose","filter","Boolean","timeslice","isInBufferRange","insertPosition","timesliceAtInsertPosition","splice","streamName","timeSlice","fromTime","toTime","getLoadedTimeRange","XVIZObject","prune"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport XVIZObject from '../objects/xviz-object';\nimport assert from '../utils/assert';\nimport {findInsertPos, INSERT_POSITION} from '../utils/search';\n\n// Insert positions\nconst LEFT = INSERT_POSITION.LEFT;\nconst RIGHT = INSERT_POSITION.RIGHT;\n\n// Buffer types\nconst UNLIMITED = 0;\nconst OFFSET = 1;\nconst FIXED = 2;\n\nexport default class XVIZStreamBuffer {\n  /**\n   * constructor\n   * @param {object} options\n   * @param {number} options.startOffset - desired start of buffer to keep in memory\n   *  relative to the current time.\n   * @param {number} options.endOffset - desired end of buffer to keep in memory\n   *  relative to the current time.\n   */\n  constructor({startOffset = null, endOffset = null, maxLength = null} = {}) {\n    if (Number.isFinite(startOffset) && Number.isFinite(endOffset)) {\n      assert(startOffset <= 0 && endOffset >= 0, 'Steam buffer offset');\n      this.bufferType = OFFSET;\n    } else {\n      this.bufferType = UNLIMITED;\n    }\n\n    this.options = {\n      startOffset,\n      endOffset,\n      maxLength\n    };\n\n    /* Desired buffer range, in timestamps */\n    this.bufferStart = null;\n    this.bufferEnd = null;\n    /* Sorted timeslices */\n    this.timeslices = [];\n    /* Sorted stream slices */\n    this.streams = {};\n    this.videos = {};\n    /* Update counter */\n    this.lastUpdate = 0;\n\n    this.hasBuffer = this.hasBuffer.bind(this);\n  }\n\n  /**\n   * @property {number} the count of timeslices in buffer\n   */\n  get size() {\n    return this.timeslices.length;\n  }\n\n  /**\n   * updates the fixed buffer range, capping it to maxLength if set\n   * @param {number} start - desired fixed start time of buffer to keep in memory\n   * @param {number} end - desired fixed end time of buffer to keep in memory\n   * @returns {start: number, end: number, oldStart: number, oldEnd: number} - the old and new buffer ranges\n   */\n  updateFixedBuffer(start, end) {\n    const {\n      bufferStart,\n      bufferEnd,\n      options: {maxLength}\n    } = this;\n    assert(start < end, 'updateFixedBuffer start / end');\n    assert(\n      this.bufferType === UNLIMITED || this.bufferType === FIXED,\n      'updateFixedBuffer multiple buffer types'\n    );\n    this.bufferType = FIXED;\n\n    if (!maxLength) {\n      // If we have no limits on buffer size, just use the new provided values\n      this.bufferStart = start;\n      this.bufferEnd = end;\n    } else if (\n      !Number.isFinite(bufferStart) ||\n      start > bufferEnd + maxLength ||\n      start < bufferStart - maxLength\n    ) {\n      // If we have a limit but this is our first range definition, or this is so far before the existing\n      // buffer that there's no overlap, use the provided start and determine end based on max buffer length\n      this.bufferStart = start;\n      this.bufferEnd = Math.min(end, start + maxLength);\n    } else if (start < bufferStart) {\n      // If this is before the existing buffer but close enough to have overlap, use the provided start\n      // and determine the end based on max buffer length and the existing buffer end\n      this.bufferStart = start;\n      this.bufferEnd = Math.min(bufferEnd, start + maxLength);\n    } else {\n      // Otherwise, we're past the end of the existing buffer and either extend the existing buffer\n      // or start a new buffer based on maxLength\n      this.bufferStart = Math.min(bufferEnd, end - maxLength);\n      this.bufferEnd = Math.min(this.bufferStart + maxLength, end);\n    }\n    this._pruneBuffer();\n    return {start: this.bufferStart, end: this.bufferEnd, oldStart: bufferStart, oldEnd: bufferEnd};\n  }\n\n  /**\n   * Gets the time range that the buffer is accepting data for\n   * @returns {object} - {start | null, end | null} timestamps if any timeslice is loaded\n   */\n  getBufferRange() {\n    if (this.bufferType !== UNLIMITED) {\n      const {bufferStart, bufferEnd} = this;\n      if (Number.isFinite(bufferStart)) {\n        // buffer range should be ignored if setCurrentTime has not been called\n        return {start: bufferStart, end: bufferEnd};\n      }\n    }\n    return {start: null, end: null};\n  }\n\n  /**\n   * Gets the buffered time range\n   * @returns {object | null} - {start, end} timestamps if any timeslice is loaded\n   */\n  getLoadedTimeRange() {\n    const {timeslices} = this;\n    const len = timeslices.length;\n\n    if (len > 0) {\n      return {\n        start: timeslices[0].timestamp,\n        end: timeslices[len - 1].timestamp\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Gets timeslices within a given time range.\n   * @params {number, optional} start - start timestamp (inclusive)\n   * @params {number, optional} end - end timestamp (inclusive)\n   * @returns {array} - loaded timeslices within range\n   */\n  getTimeslices({start, end} = {}) {\n    const {timeslices} = this;\n    const startIndex = Number.isFinite(start) ? this._indexOf(start, LEFT) : 0;\n    const endIndex = Number.isFinite(end) ? this._indexOf(end, RIGHT) : timeslices.length;\n    return timeslices.slice(startIndex, endIndex);\n  }\n\n  /**\n   * Gets loaded stream slices within the current buffer\n   */\n  getStreams() {\n    return {...this.streams};\n  }\n\n  /**\n   * Gets loaded video frames within the current buffer\n   */\n  getVideos() {\n    return {...this.videos};\n  }\n\n  /**\n   * Get vehicle poses within the current buffer\n   */\n  getVehiclePoses() {\n    return this.timeslices.map(t => t.vehiclePose).filter(Boolean);\n  }\n\n  /**\n   * Add a new timeslice object into the timeline\n   * @params {object} timeslice - timeslice object from XVIZ stream\n   */\n  insert(timeslice) {\n    // backwards compatibility - normalize time slice\n    timeslice.streams = timeslice.streams || {};\n\n    const {timeslices} = this;\n    const {timestamp} = timeslice;\n\n    if (!this.isInBufferRange(timestamp)) {\n      return false;\n    }\n\n    const insertPosition = this._indexOf(timestamp, LEFT);\n    const timesliceAtInsertPosition = timeslices[insertPosition];\n\n    if (timesliceAtInsertPosition && timesliceAtInsertPosition.timestamp === timestamp) {\n      // Same timestamp, needs a merge\n      timeslices[insertPosition] = {\n        ...timesliceAtInsertPosition,\n        ...timeslice,\n        streams: {\n          ...timesliceAtInsertPosition.streams,\n          ...timeslice.streams\n        },\n        videos: {\n          ...timesliceAtInsertPosition.videos,\n          ...timeslice.videos\n        }\n      };\n    } else {\n      timeslices.splice(insertPosition, 0, timeslice);\n    }\n\n    for (const streamName in timeslice.streams) {\n      this.streams[streamName] = timeslices\n        .map(timeSlice => timeSlice.streams[streamName])\n        .filter(Boolean);\n    }\n\n    // TODO - remove when updating to v2\n    for (const streamName in timeslice.videos) {\n      this.videos[streamName] = timeslices\n        .map(timeSlice => timeSlice.videos && timeSlice.videos[streamName])\n        .filter(Boolean);\n    }\n\n    this.lastUpdate++;\n    return true;\n  }\n\n  /**\n   * Set the current timestamp\n   * May drop timeslices that are not in range\n   * @params {number} timestamp - timestamp of the playhead\n   */\n  setCurrentTime(timestamp) {\n    if (this.bufferType === OFFSET) {\n      const {\n        options: {startOffset, endOffset}\n      } = this;\n      this.bufferStart = timestamp + startOffset;\n      this.bufferEnd = timestamp + endOffset;\n      this._pruneBuffer();\n    }\n  }\n\n  /**\n   * Override Object.prototype.valueOf\n   * This is used to trigger a selector update without creating a new XVIZStreamBuffer instance\n   */\n  valueOf() {\n    return this.lastUpdate;\n  }\n\n  /**\n   * Provide interface for video-synchronizer to test for valid gps-based time range data.\n   *\n   * @params {number} fromTime is the gps time start of data\n   * @params {number} toTime is the gps time end of data\n   * @returns {bool} If we have no data, always return true, else true is returned\n   *                 if the time range is satisfied\n   */\n  hasBuffer(fromTime, toTime) {\n    if (!this.timeslices.length) {\n      return true;\n    }\n    const {start, end} = this.getLoadedTimeRange();\n    return fromTime >= start && toTime <= end;\n  }\n\n  /**\n   * Check if a timestamp is inside the desired buffer range\n   * @params {number} timestamp\n   * @returns {bool}\n   */\n  isInBufferRange(timestamp) {\n    const {bufferStart, bufferEnd, bufferType} = this;\n    if (bufferType !== UNLIMITED && Number.isFinite(bufferStart)) {\n      return timestamp >= bufferStart && timestamp <= bufferEnd;\n    }\n    return true;\n  }\n\n  _pruneBuffer() {\n    const {timeslices} = this;\n\n    if (timeslices.length) {\n      const startIndex = this._indexOf(this.bufferStart, LEFT);\n      const endIndex = this._indexOf(this.bufferEnd, RIGHT);\n\n      XVIZObject.prune(this.bufferStart, this.bufferEnd);\n\n      if (startIndex > 0 || endIndex < timeslices.length) {\n        // Drop frames that are outside of the buffer\n        timeslices.splice(endIndex);\n        timeslices.splice(0, startIndex);\n\n        this.lastUpdate++;\n      }\n    }\n  }\n\n  /**\n   * Return insert position for timeslice data given a timestamp\n   * @params {number} timestamp\n   * @params {number} insertPosition - insert to the left or right of the equal element.\n   * @returns {number} index of insert position\n   */\n  _indexOf(timestamp, insertPosition = LEFT) {\n    const {timeslices} = this;\n    return findInsertPos(timeslices, timestamp, insertPosition);\n  }\n}\n"],"file":"xviz-stream-buffer.js"}