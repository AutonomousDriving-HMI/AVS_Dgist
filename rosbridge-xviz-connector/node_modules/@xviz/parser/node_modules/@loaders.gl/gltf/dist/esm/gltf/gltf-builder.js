import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/esm/inherits";

/* eslint-disable camelcase, max-statements */
import GLBBuilder from '../glb/glb-builder';
import packBinaryJson from '../packed-json/pack-binary-json';
import { assert, getImageSize } from '@loaders.gl/core'; // Ideally we should just use KHR_draco_mesh_compression, but it requires saving uncompressed data?
// TODO: until the ideal, we need to export these

var UBER_MESH_EXTENSION = 'UBER_draco_mesh_compression';
var UBER_POINT_CLOUD_EXTENSION = 'UBER_draco_point_cloud_compression';

var GLTFBuilder =
/*#__PURE__*/
function (_GLBBuilder) {
  _inherits(GLTFBuilder, _GLBBuilder);

  function GLTFBuilder() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, GLTFBuilder);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTFBuilder).call(this, options)); // Soft dependency on DRACO, app needs to import and supply these

    _this.DracoEncoder = options.DracoEncoder;
    _this.DracoDecoder = options.DracoDecoder;
    Object.assign(_this.json, {
      meshes: []
    });
    return _this;
  } // TODO - support encoding to non-GLB versions of glTF format
  // Encode as a textual JSON file with binary data in base64 data URLs.
  // encodeAsDataURLs(options) {
  //   throw new Error('Not yet implemented');
  // }
  // Encode as a JSON with all images (and buffers?) in separate binary files
  // encodeAsSeparateFiles(options) {
  //   throw new Error('Not yet imlemented');
  // }
  // Add an extra application-defined key to the top-level data structure
  // By default packs JSON by extracting binary data and replacing it with JSON pointers


  _createClass(GLTFBuilder, [{
    key: "addApplicationData",
    value: function addApplicationData(key, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var jsonData = packOptions.nopack ? data : packBinaryJson(data, this, packOptions);
      this.json[key] = jsonData;
      return this;
    } // `extras` - Standard GLTF field for storing application specific data
    // By default packs JSON by extracting binary data and replacing it with JSON pointers

  }, {
    key: "addExtraData",
    value: function addExtraData(key, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var packedJson = !packOptions.nopack && packBinaryJson(data, this, packOptions);
      this.json.extras = this.json.extras || {};
      this.json.extras[key] = packedJson;
      return this;
    } // Add to standard GLTF top level extension object, mark as used
    // By default packs JSON by extracting binary data and replacing it with JSON pointers

  }, {
    key: "addExtension",
    value: function addExtension(extensionName, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      assert(data);
      var packedJson = !packOptions.nopack && packBinaryJson(data, this, packOptions);
      this.json.extensions = this.json.extensions || {};
      this.json.extensions[extensionName] = packedJson;
      this.registerUsedExtension(extensionName);
      return this;
    } // Standard GLTF top level extension object, mark as used and required
    // By default packs JSON by extracting binary data and replacing it with JSON pointers

  }, {
    key: "addRequiredExtension",
    value: function addRequiredExtension(extensionName, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      assert(data);
      var packedJson = !packOptions.nopack && packBinaryJson(data, this, packOptions);
      this.addExtension(extensionName, packedJson);
      this.registerRequiredExtension(extensionName);
      return this;
    } // Add extensionName to list of used extensions

  }, {
    key: "registerUsedExtension",
    value: function registerUsedExtension(extensionName) {
      this.json.extensionsUsed = this.json.extensionsUsed || [];

      if (!this.json.extensionsUsed.find(function (ext) {
        return ext === extensionName;
      })) {
        this.json.extensionsUsed.push(extensionName);
      }
    } // Add extensionName to list of required extensions

  }, {
    key: "registerRequiredExtension",
    value: function registerRequiredExtension(extensionName) {
      this.registerUsedExtension(extensionName);
      this.json.extensionsRequired = this.json.extensionsRequired || [];

      if (!this.json.extensionsRequired.find(function (ext) {
        return ext === extensionName;
      })) {
        this.json.extensionsRequired.push(extensionName);
      }
    } // POINTS:  0x0000,
    // LINES: 0x0001,
    // LINE_LOOP: 0x0002,
    // LINE_STRIP:  0x0003,
    // TRIANGLES: 0x0004,
    // TRIANGLE_STRIP:  0x0005,
    // TRIANGLE_FAN:  0x0006,

  }, {
    key: "addMesh",
    value: function addMesh(attributes, indices) {
      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

      var accessors = this._addAttributes(attributes);

      var glTFMesh = {
        primitives: [{
          attributes: accessors,
          indices: indices,
          mode: mode
        }]
      };
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
  }, {
    key: "addPointCloud",
    value: function addPointCloud(attributes) {
      var accessorIndices = this._addAttributes(attributes);

      var glTFMesh = {
        primitives: [{
          attributes: accessorIndices,
          mode: 0 // GL.POINTS

        }]
      };
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    } // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/
    //   KHR_draco_mesh_compression
    // NOTE: in contrast to glTF spec, does not add fallback data

  }, {
    key: "addCompressedMesh",
    value: function addCompressedMesh(attributes, indices) {
      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

      if (!this.DracoEncoder || !this.DracoDecoder) {
        throw new Error('DracoEncoder/Decoder not available');
      }

      var dracoEncoder = new this.DracoEncoder();
      var compressedData = dracoEncoder.encodeMesh(attributes); // Draco compression may change the order and number of vertices in a mesh.
      // To satisfy the requirement that accessors properties be correct for both
      // compressed and uncompressed data, generators should create uncompressed
      // attributes and indices using data that has been decompressed from the Draco buffer,
      // rather than the original source data.

      var dracoDecoder = new this.DracoDecoder();
      var decodedData = dracoDecoder.decodeMesh(attributes);

      var fauxAccessors = this._addFauxAttributes(decodedData.attributes);

      var bufferViewIndex = this.addBufferView(compressedData);
      var glTFMesh = {
        primitives: [{
          attributes: fauxAccessors,
          mode: mode,
          // GL.POINTS
          extensions: _defineProperty({}, UBER_MESH_EXTENSION, {
            bufferView: bufferViewIndex
          })
        }]
      };
      this.registerRequiredExtension(UBER_MESH_EXTENSION);
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
  }, {
    key: "addCompressedPointCloud",
    value: function addCompressedPointCloud(attributes) {
      if (!this.DracoEncoder || !this.DracoDecoder) {
        throw new Error('DracoEncoder/Decoder not available');
      }

      var dracoEncoder = new this.DracoEncoder();
      var compressedData = dracoEncoder.encodePointCloud(attributes);
      var bufferViewIndex = this.addBufferView(compressedData);
      var glTFMesh = {
        primitives: [{
          attributes: {},
          // This will be populated after decompression
          mode: 0,
          // GL.POINTS
          extensions: _defineProperty({}, UBER_POINT_CLOUD_EXTENSION, {
            bufferView: bufferViewIndex
          })
        }]
      };
      this.registerRequiredExtension(UBER_POINT_CLOUD_EXTENSION);
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    } // Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
    // Buffer will be copied into BIN chunk during "pack"
    // Currently encodes as glTF image

  }, {
    key: "addImage",
    value: function addImage(imageData) {
      var bufferViewIndex = this.addBufferView(imageData); // Get the properties of the image to add as metadata.

      var sizeAndType = getImageSize(imageData) || {};

      if (sizeAndType) {
        // width and height are non-spec fields
        var mimeType = sizeAndType.mimeType,
            width = sizeAndType.width,
            height = sizeAndType.height;
        this.json.images.push({
          bufferView: bufferViewIndex,
          mimeType: mimeType,
          width: width,
          height: height
        });
      } else {
        // TODO: Spec violation, if we are using a bufferView, mimeType must be defined
        //       https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images
        //       "a reference to a bufferView; in that case mimeType must be defined."
        this.json.images.push({
          bufferView: bufferViewIndex
        });
      }

      return this.json.images.length - 1;
    }
  }]);

  return GLTFBuilder;
}(GLBBuilder);

export { GLTFBuilder as default };
//# sourceMappingURL=gltf-builder.js.map