"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _math = require("math.gl");

var _baseObject = _interopRequireDefault(require("./base-object"));

var _geometry = require("../utils/geometry");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var defaultCollection = null;
var serialIndex = 0;
/**
 * Contains metadata and state of each XVIZ object
 */

var XVIZObject =
/*#__PURE__*/
function (_BaseObject) {
  _inherits(XVIZObject, _BaseObject);

  _createClass(XVIZObject, null, [{
    key: "setDefaultCollection",
    value: function setDefaultCollection(collection) {
      defaultCollection = collection;
    }
  }]);

  function XVIZObject(_ref) {
    var _this;

    var id = _ref.id,
        timestamp = _ref.timestamp;

    _classCallCheck(this, XVIZObject);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(XVIZObject).call(this));
    /* Persistent */

    _this.id = id;
    _this.index = serialIndex++;
    _this.state = {};
    _this.startTime = timestamp;
    _this.endTime = timestamp; // Use Map here for the clear() method without creating a new object

    _this._props = new Map();
    _this._streams = new Map();
    _this._geometry = null;
    return _this;
  }

  _createClass(XVIZObject, [{
    key: "getBearingToObject",
    value: function getBearingToObject(object) {
      var myPosition = this.position;
      var otherPosition = object.position;

      if (myPosition && otherPosition) {
        // Look at the other object
        // TODO - handle degenerate case when in same position
        var bearing = Math.atan2(otherPosition[1] - myPosition[1], otherPosition[0] - myPosition[0]) / Math.PI * 180;
        return bearing;
      }

      return null;
    } // Helper, calculates distance from specified XVIZ object to car
    // 2D distance only, ignores z coordinate

  }, {
    key: "getDistanceToObject",
    value: function getDistanceToObject(object) {
      var myPosition = this.position;
      var otherPosition = object.position;
      var distance = null;

      if (myPosition && otherPosition) {
        // TODO - calc distance to object trackingPoint
        // Ultimately distance might be desired as between closest surface points
        // We must disregard height to compensate for other choices in our ingestion stack
        distance = new _math.Vector2(myPosition).distance(otherPosition);
        distance = Math.round(distance * 10) / 10;
      }

      return distance;
    }
  }, {
    key: "getProp",
    value: function getProp(name) {
      return this._props.get(name);
    }
  }, {
    key: "getFeature",
    value: function getFeature(streamName) {
      return this._streams.get(streamName);
    } // PRIVATE METHODS

  }, {
    key: "_observe",
    value: function _observe(timestamp) {
      this.startTime = Math.min(this.startTime, timestamp);
      this.endTime = Math.max(this.endTime, timestamp);
    }
  }, {
    key: "_addFeature",
    value: function _addFeature(streamName, feature) {
      this._streams.set(streamName, feature); // populate the feature with object props


      feature.index = this.index;
      feature.state = this.state;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._props[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var entry = _step.value;
          feature[entry[0]] = entry[1];
        } // save feature geometry for tracking

      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var p = feature.center || feature.vertices;

      if (!p || !Array.isArray(p)) {
        return;
      }

      if (Number.isFinite(p[0])) {
        p[2] = p[2] || 0;
      } else if (this._geometry) {
        // Prefer point over point array
        return;
      } // store the point(s) as is


      this._geometry = p;
    }
  }, {
    key: "_setState",
    value: function _setState(name, value) {
      if (name) {
        this.state[name] = value;
      }
    }
  }, {
    key: "_setProp",
    value: function _setProp(name, value) {
      this._props.set(name, value);
    } // This should be called at the beginning of `getCurrentFrame`

  }, {
    key: "_reset",
    value: function _reset() {
      if (this._props.size) {
        this._props.clear();
      }

      if (this._streams.size) {
        this._streams.clear();
      } // clear the cached position


      this._geometry = null;
    }
  }, {
    key: "position",
    // returns a single tracking point for this object
    get: function get() {
      var p = this._geometry;

      if (!p) {
        return null;
      }

      if (Number.isFinite(p[0])) {
        return p;
      }

      this._geometry = (0, _geometry.getCentroid)(p);
      return this._geometry;
    } // this prop is cleared every time `reset` is called

  }, {
    key: "isValid",
    get: function get() {
      return Boolean(this._geometry);
    }
  }, {
    key: "streamNames",
    get: function get() {
      return this._streams.keys();
    }
  }], [{
    key: "observe",
    value: function observe(id, timestamp) {
      return defaultCollection && defaultCollection.observe(id, timestamp);
    }
  }, {
    key: "get",
    value: function get(id) {
      return defaultCollection && defaultCollection.get(id);
    }
  }, {
    key: "clear",
    value: function clear() {
      return defaultCollection && defaultCollection.clear();
    }
  }, {
    key: "count",
    value: function count() {
      return defaultCollection && defaultCollection.count();
    }
  }, {
    key: "resetAll",
    value: function resetAll() {
      return defaultCollection && defaultCollection.resetAll();
    }
  }, {
    key: "getAll",
    value: function getAll() {
      return defaultCollection && defaultCollection.getAll();
    }
  }, {
    key: "getAllInCurrentFrame",
    value: function getAllInCurrentFrame() {
      return defaultCollection && defaultCollection.getAllInCurrentFrame();
    }
  }, {
    key: "prune",
    value: function prune(startTime, endTime) {
      return defaultCollection && defaultCollection.prune(startTime, endTime);
    }
  }]);

  return XVIZObject;
}(_baseObject.default);

exports.default = XVIZObject;
//# sourceMappingURL=xviz-object.js.map