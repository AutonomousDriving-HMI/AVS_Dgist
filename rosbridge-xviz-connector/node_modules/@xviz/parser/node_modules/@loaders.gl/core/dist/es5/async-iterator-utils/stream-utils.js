"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStreamIterator = getStreamIterator;
exports.concatenateReadStream = concatenateReadStream;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _globals = require("../utils/globals");

var _memoryCopyUtils = require("../binary-utils/memory-copy-utils");

function getStreamIterator(stream) {
  // NODE 10+: stream is an asyncIterator
  if (typeof stream[Symbol.asyncIterator] === 'function') {
    return stream;
  } // WhatWG: stream is supposed to have a `getIterator` method


  if (typeof stream.getIterator === 'function') {
    return stream.getIterator();
  }

  return _globals.isBrowser ? makeBrowserStreamIterator(stream) : makeNodeStreamIterator(stream);
} // BROWSER IMPLEMENTATION
// See https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate


function makeBrowserStreamIterator(_x) {
  return _makeBrowserStreamIterator.apply(this, arguments);
} // NODE <10 IMPLEMENTATION
// See https://github.com/bustle/streaming-iterables, MIT license


function _makeBrowserStreamIterator() {
  _makeBrowserStreamIterator = (0, _wrapAsyncGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(stream) {
    var reader, _ref, done, value;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // In the brower, we first need to get a lock on the stream
            reader = stream.getReader();
            _context.prev = 1;

          case 2:
            if (!true) {
              _context.next = 14;
              break;
            }

            _context.next = 5;
            return (0, _awaitAsyncGenerator2.default)(reader.read());

          case 5:
            _ref = _context.sent;
            done = _ref.done;
            value = _ref.value;

            if (!done) {
              _context.next = 10;
              break;
            }

            return _context.abrupt("return");

          case 10:
            _context.next = 12;
            return value;

          case 12:
            _context.next = 2;
            break;

          case 14:
            _context.prev = 14;
            reader.releaseLock();
            return _context.finish(14);

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1,, 14, 17]]);
  }));
  return _makeBrowserStreamIterator.apply(this, arguments);
}

function makeNodeStreamIterator(_x2) {
  return _makeNodeStreamIterator.apply(this, arguments);
}

function _makeNodeStreamIterator() {
  _makeNodeStreamIterator = (0, _wrapAsyncGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee2(stream) {
    var data;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!true) {
              _context2.next = 12;
              break;
            }

            data = stream.read();

            if (!(data !== null)) {
              _context2.next = 6;
              break;
            }

            _context2.next = 5;
            return data;

          case 5:
            return _context2.abrupt("continue", 0);

          case 6:
            if (!stream._readableState.ended) {
              _context2.next = 8;
              break;
            }

            return _context2.abrupt("return");

          case 8:
            _context2.next = 10;
            return (0, _awaitAsyncGenerator2.default)(onceReadable(stream));

          case 10:
            _context2.next = 0;
            break;

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _makeNodeStreamIterator.apply(this, arguments);
}

function onceReadable(_x3) {
  return _onceReadable.apply(this, arguments);
} // TODO - remove? can this be handled via corresponding AsyncIterator function?


function _onceReadable() {
  _onceReadable = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee3(stream) {
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", new Promise(function (resolve) {
              stream.once('readable', resolve);
            }));

          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _onceReadable.apply(this, arguments);
}

function concatenateReadStream(readStream) {
  var arrayBuffer = new ArrayBuffer();
  var string = '';
  return new Promise(function (resolve, reject) {
    readStream.data(function (chunk) {
      if (typeof chunk === 'string') {
        string += chunk;
      } else {
        arrayBuffer = (0, _memoryCopyUtils.concatenateArrayBuffers)(arrayBuffer, chunk);
      }
    });
    readStream.on('error', function (error) {
      return reject(error);
    });
    readStream.on('end', function () {
      if (readStream.complete) {
        resolve(arrayBuffer || string);
      } else {
        reject('The connection was terminated while the message was still being sent');
      }
    });
  });
}
//# sourceMappingURL=stream-utils.js.map