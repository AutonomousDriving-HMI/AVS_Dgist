function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2019 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import XVIZObject from '../objects/xviz-object';
import assert from '../utils/assert';
import { findInsertPos, INSERT_POSITION } from '../utils/search'; // Insert positions

const LEFT = INSERT_POSITION.LEFT;
const RIGHT = INSERT_POSITION.RIGHT; // Buffer types

const UNLIMITED = 0;
const OFFSET = 1;
const FIXED = 2;
export default class XVIZStreamBuffer {
  /**
   * constructor
   * @param {object} options
   * @param {number} options.startOffset - desired start of buffer to keep in memory
   *  relative to the current time.
   * @param {number} options.endOffset - desired end of buffer to keep in memory
   *  relative to the current time.
   */
  constructor() {
    let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$startOffset = _ref.startOffset,
        startOffset = _ref$startOffset === void 0 ? null : _ref$startOffset,
        _ref$endOffset = _ref.endOffset,
        endOffset = _ref$endOffset === void 0 ? null : _ref$endOffset,
        _ref$maxLength = _ref.maxLength,
        maxLength = _ref$maxLength === void 0 ? null : _ref$maxLength;

    if (Number.isFinite(startOffset) && Number.isFinite(endOffset)) {
      assert(startOffset <= 0 && endOffset >= 0, 'Steam buffer offset');
      this.bufferType = OFFSET;
    } else {
      this.bufferType = UNLIMITED;
    }

    this.options = {
      startOffset,
      endOffset,
      maxLength
    };
    /* Desired buffer range, in timestamps */

    this.bufferStart = null;
    this.bufferEnd = null;
    /* Sorted timeslices */

    this.timeslices = [];
    /* Sorted stream slices */

    this.streams = {};
    this.videos = {};
    /* Update counter */

    this.lastUpdate = 0;
    this.hasBuffer = this.hasBuffer.bind(this);
  }
  /**
   * @property {number} the count of timeslices in buffer
   */


  get size() {
    return this.timeslices.length;
  }
  /**
   * updates the fixed buffer range, capping it to maxLength if set
   * @param {number} start - desired fixed start time of buffer to keep in memory
   * @param {number} end - desired fixed end time of buffer to keep in memory
   * @returns {start: number, end: number, oldStart: number, oldEnd: number} - the old and new buffer ranges
   */


  updateFixedBuffer(start, end) {
    const bufferStart = this.bufferStart,
          bufferEnd = this.bufferEnd,
          maxLength = this.options.maxLength;
    assert(start < end, 'updateFixedBuffer start / end');
    assert(this.bufferType === UNLIMITED || this.bufferType === FIXED, 'updateFixedBuffer multiple buffer types');
    this.bufferType = FIXED;

    if (!maxLength) {
      // If we have no limits on buffer size, just use the new provided values
      this.bufferStart = start;
      this.bufferEnd = end;
    } else if (!Number.isFinite(bufferStart) || start > bufferEnd + maxLength || start < bufferStart - maxLength) {
      // If we have a limit but this is our first range definition, or this is so far before the existing
      // buffer that there's no overlap, use the provided start and determine end based on max buffer length
      this.bufferStart = start;
      this.bufferEnd = Math.min(end, start + maxLength);
    } else if (start < bufferStart) {
      // If this is before the existing buffer but close enough to have overlap, use the provided start
      // and determine the end based on max buffer length and the existing buffer end
      this.bufferStart = start;
      this.bufferEnd = Math.min(bufferEnd, start + maxLength);
    } else {
      // Otherwise, we're past the end of the existing buffer and either extend the existing buffer
      // or start a new buffer based on maxLength
      this.bufferStart = Math.min(bufferEnd, end - maxLength);
      this.bufferEnd = Math.min(this.bufferStart + maxLength, end);
    }

    this._pruneBuffer();

    return {
      start: this.bufferStart,
      end: this.bufferEnd,
      oldStart: bufferStart,
      oldEnd: bufferEnd
    };
  }
  /**
   * Gets the time range that the buffer is accepting data for
   * @returns {object} - {start | null, end | null} timestamps if any timeslice is loaded
   */


  getBufferRange() {
    if (this.bufferType !== UNLIMITED) {
      const bufferStart = this.bufferStart,
            bufferEnd = this.bufferEnd;

      if (Number.isFinite(bufferStart)) {
        // buffer range should be ignored if setCurrentTime has not been called
        return {
          start: bufferStart,
          end: bufferEnd
        };
      }
    }

    return {
      start: null,
      end: null
    };
  }
  /**
   * Gets the buffered time range
   * @returns {object | null} - {start, end} timestamps if any timeslice is loaded
   */


  getLoadedTimeRange() {
    const timeslices = this.timeslices;
    const len = timeslices.length;

    if (len > 0) {
      return {
        start: timeslices[0].timestamp,
        end: timeslices[len - 1].timestamp
      };
    }

    return null;
  }
  /**
   * Gets timeslices within a given time range.
   * @params {number, optional} start - start timestamp (inclusive)
   * @params {number, optional} end - end timestamp (inclusive)
   * @returns {array} - loaded timeslices within range
   */


  getTimeslices() {
    let _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        start = _ref2.start,
        end = _ref2.end;

    const timeslices = this.timeslices;
    const startIndex = Number.isFinite(start) ? this._indexOf(start, LEFT) : 0;
    const endIndex = Number.isFinite(end) ? this._indexOf(end, RIGHT) : timeslices.length;
    return timeslices.slice(startIndex, endIndex);
  }
  /**
   * Gets loaded stream slices within the current buffer
   */


  getStreams() {
    return _objectSpread({}, this.streams);
  }
  /**
   * Gets loaded video frames within the current buffer
   */


  getVideos() {
    return _objectSpread({}, this.videos);
  }
  /**
   * Get vehicle poses within the current buffer
   */


  getVehiclePoses() {
    return this.timeslices.map(t => t.vehiclePose).filter(Boolean);
  }
  /**
   * Add a new timeslice object into the timeline
   * @params {object} timeslice - timeslice object from XVIZ stream
   */


  insert(timeslice) {
    // backwards compatibility - normalize time slice
    timeslice.streams = timeslice.streams || {};
    const timeslices = this.timeslices;
    const timestamp = timeslice.timestamp;

    if (!this.isInBufferRange(timestamp)) {
      return false;
    }

    const insertPosition = this._indexOf(timestamp, LEFT);

    const timesliceAtInsertPosition = timeslices[insertPosition];

    if (timesliceAtInsertPosition && timesliceAtInsertPosition.timestamp === timestamp) {
      // Same timestamp, needs a merge
      timeslices[insertPosition] = _objectSpread({}, timesliceAtInsertPosition, timeslice, {
        streams: _objectSpread({}, timesliceAtInsertPosition.streams, timeslice.streams),
        videos: _objectSpread({}, timesliceAtInsertPosition.videos, timeslice.videos)
      });
    } else {
      timeslices.splice(insertPosition, 0, timeslice);
    }

    for (const streamName in timeslice.streams) {
      this.streams[streamName] = timeslices.map(timeSlice => timeSlice.streams[streamName]).filter(Boolean);
    } // TODO - remove when updating to v2


    for (const streamName in timeslice.videos) {
      this.videos[streamName] = timeslices.map(timeSlice => timeSlice.videos && timeSlice.videos[streamName]).filter(Boolean);
    }

    this.lastUpdate++;
    return true;
  }
  /**
   * Set the current timestamp
   * May drop timeslices that are not in range
   * @params {number} timestamp - timestamp of the playhead
   */


  setCurrentTime(timestamp) {
    if (this.bufferType === OFFSET) {
      const _this$options = this.options,
            startOffset = _this$options.startOffset,
            endOffset = _this$options.endOffset;
      this.bufferStart = timestamp + startOffset;
      this.bufferEnd = timestamp + endOffset;

      this._pruneBuffer();
    }
  }
  /**
   * Override Object.prototype.valueOf
   * This is used to trigger a selector update without creating a new XVIZStreamBuffer instance
   */


  valueOf() {
    return this.lastUpdate;
  }
  /**
   * Provide interface for video-synchronizer to test for valid gps-based time range data.
   *
   * @params {number} fromTime is the gps time start of data
   * @params {number} toTime is the gps time end of data
   * @returns {bool} If we have no data, always return true, else true is returned
   *                 if the time range is satisfied
   */


  hasBuffer(fromTime, toTime) {
    if (!this.timeslices.length) {
      return true;
    }

    const _this$getLoadedTimeRa = this.getLoadedTimeRange(),
          start = _this$getLoadedTimeRa.start,
          end = _this$getLoadedTimeRa.end;

    return fromTime >= start && toTime <= end;
  }
  /**
   * Check if a timestamp is inside the desired buffer range
   * @params {number} timestamp
   * @returns {bool}
   */


  isInBufferRange(timestamp) {
    const bufferStart = this.bufferStart,
          bufferEnd = this.bufferEnd,
          bufferType = this.bufferType;

    if (bufferType !== UNLIMITED && Number.isFinite(bufferStart)) {
      return timestamp >= bufferStart && timestamp <= bufferEnd;
    }

    return true;
  }

  _pruneBuffer() {
    const timeslices = this.timeslices;

    if (timeslices.length) {
      const startIndex = this._indexOf(this.bufferStart, LEFT);

      const endIndex = this._indexOf(this.bufferEnd, RIGHT);

      XVIZObject.prune(this.bufferStart, this.bufferEnd);

      if (startIndex > 0 || endIndex < timeslices.length) {
        // Drop frames that are outside of the buffer
        timeslices.splice(endIndex);
        timeslices.splice(0, startIndex);
        this.lastUpdate++;
      }
    }
  }
  /**
   * Return insert position for timeslice data given a timestamp
   * @params {number} timestamp
   * @params {number} insertPosition - insert to the left or right of the equal element.
   * @returns {number} index of insert position
   */


  _indexOf(timestamp) {
    let insertPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LEFT;
    const timeslices = this.timeslices;
    return findInsertPos(timeslices, timestamp, insertPosition);
  }

}
//# sourceMappingURL=xviz-stream-buffer.js.map