"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _gltfTypeUtils = require("../utils/gltf-type-utils");

var _glbParser = _interopRequireDefault(require("../glb/glb-parser"));

var GL_SAMPLER = {
  TEXTURE_MAG_FILTER: 0x2800,
  TEXTURE_MIN_FILTER: 0x2801,
  TEXTURE_WRAP_S: 0x2802,
  TEXTURE_WRAP_T: 0x2803
};
var SAMPLER_PARAMETER_GLTF_TO_GL = {
  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
  wrapT: GL_SAMPLER.TEXTURE_WRAP_T
};
var DEFAULT_OPTIONS = {
  createImages: false
};

var GLTFParser =
/*#__PURE__*/
function () {
  function GLTFParser() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, GLTFParser);
    // TODO - move parsing to parse
    this.log = console; // eslint-disable-line

    this.out = {};
    this.options = Object.assign({}, DEFAULT_OPTIONS, options); // Soft dependency on Draco, needs to be imported and supplied by app

    this.DracoDecoder = this.options.DracoDecoder || null;
  }

  (0, _createClass2.default)(GLTFParser, [{
    key: "parse",
    value: function parse(gltf) {
      var optionsParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = Object.assign({}, this.options, optionsParam); // GLTF can be JSON or binary (GLB)

      if (gltf instanceof ArrayBuffer) {
        this.glbParser = new _glbParser.default();
        this.gltf = this.glbParser.parse(gltf).json;
        this.json = this.gltf;
      } else {
        this.glbParser = null;
        this.gltf = gltf;
        this.json = gltf;
      }

      this._resolveToTree(options);

      return this.gltf;
    }
  }, {
    key: "parseAsync",
    value: function parseAsync(gltf) {
      var _this = this;

      var optionsParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = Object.assign({}, this.options, optionsParam); // GLTF can be JSON or binary (GLB)

      if (gltf instanceof ArrayBuffer) {
        this.glbParser = new _glbParser.default();
        this.gltf = this.glbParser.parse(gltf).json;
        this.json = this.gltf;
      } else {
        this.glbParser = null;
        this.gltf = gltf;
        this.json = gltf;
      } // TODO: consider using async


      return this._loadLinkedAssets(options).then(function () {
        _this._resolveToTree(options);

        return _this.gltf;
      });
    } // Accessors

  }, {
    key: "getApplicationData",
    value: function getApplicationData(key) {
      // TODO - Data is already unpacked by GLBParser
      var data = this.json[key];
      return data;
    }
  }, {
    key: "getExtraData",
    value: function getExtraData(key) {
      // TODO - Data is already unpacked by GLBParser
      var extras = this.json.extras || {};
      return extras[key];
    }
  }, {
    key: "getExtension",
    value: function getExtension(extensionName) {
      // TODO - Data is already unpacked by GLBParser
      return this.json.extensions[extensionName];
    }
  }, {
    key: "getRequiredExtensions",
    value: function getRequiredExtensions() {
      return this.json.extensionsRequired;
    }
  }, {
    key: "getUsedExtensions",
    value: function getUsedExtensions() {
      return this.json.extensionsUsed;
    } // DATA UNPACKING
    // Unpacks all the primitives in a mesh

  }, {
    key: "unpackMesh",
    value: function unpackMesh(mesh) {
      return mesh.primitives.map(this.unpackPrimitive.bind(this));
    } // Unpacks one mesh primitive

  }, {
    key: "unpackPrimitive",
    value: function unpackPrimitive(primitive) {
      var compressedMesh = primitive.extensions && primitive.extensions.UBER_draco_mesh_compression;
      var compressedPointCloud = primitive.extensions && primitive.extensions.UBER_draco_point_cloud_compression;
      var unpackedPrimitive = {
        mode: primitive.mode,
        material: primitive.material
      };

      if (compressedMesh) {
        var dracoDecoder = new this.DracoDecoder();
        var decodedData = dracoDecoder.decodeMesh(compressedMesh);
        dracoDecoder.destroy();
        Object.assign(unpackedPrimitive, {
          indices: decodedData.indices,
          attributes: decodedData.attributes
        });
      } else if (compressedPointCloud) {
        var _dracoDecoder = new this.DracoDecoder();

        var _decodedData = _dracoDecoder.decodePointCloud(compressedPointCloud);

        _dracoDecoder.destroy();

        Object.assign(unpackedPrimitive, {
          mode: 0,
          attributes: _decodedData.attributes
        });
      } else {// No compression - just a glTF mesh primitive
        // TODO - Resolve all accessors
      }
    } // PRIVATE

  }, {
    key: "getScene",
    value: function getScene(index) {
      return this._get('scenes', index);
    }
  }, {
    key: "getNode",
    value: function getNode(index) {
      return this._get('nodes', index);
    }
  }, {
    key: "getSkin",
    value: function getSkin(index) {
      return this._get('skins', index);
    }
  }, {
    key: "getMesh",
    value: function getMesh(index) {
      return this._get('meshes', index);
    }
  }, {
    key: "getDecompressedMesh",
    value: function getDecompressedMesh(index) {
      if (!this.DracoDecoder) {
        throw new Error('DracoDecoder not available');
      }

      var mesh = this._get('meshes', index);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = mesh.primitives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var primitive = _step.value;
          // TODO: DracoMesh extension
          var extensions = primitive.extensions;

          if ('UBER_draco_point_cloud_compression' in extensions) {
            this._decompressUberDracoPointCloud(primitive, extensions);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return mesh;
    }
  }, {
    key: "getMaterial",
    value: function getMaterial(index) {
      return this._get('materials', index);
    }
  }, {
    key: "getAccessor",
    value: function getAccessor(index) {
      return this._get('accessors', index);
    }
  }, {
    key: "getCamera",
    value: function getCamera(index) {
      return null; // TODO: fix this
    }
  }, {
    key: "getTexture",
    value: function getTexture(index) {
      return this._get('textures', index);
    }
  }, {
    key: "getSampler",
    value: function getSampler(index) {
      return this._get('samplers', index);
    }
  }, {
    key: "getImage",
    value: function getImage(index) {
      return this._get('images', index);
    }
  }, {
    key: "getBufferView",
    value: function getBufferView(index) {
      return this._get('bufferViews', index);
    }
  }, {
    key: "getBuffer",
    value: function getBuffer(index) {
      return this._get('buffers', index);
    }
  }, {
    key: "_get",
    value: function _get(array, index) {
      // check if already resolved
      if ((0, _typeof2.default)(index) === 'object') {
        return index;
      }

      var object = this.gltf[array] && this.gltf[array][index];

      if (!object) {
        console.warn("glTF file error: Could not find ".concat(array, "[").concat(index, "]")); // eslint-disable-line
      }

      return object;
    } // PARSING HELPERS

  }, {
    key: "_getFullUri",
    value: function _getFullUri(uri, base) {
      if (uri.startsWith('data:') || uri.startsWith('http:') || uri.startsWith('https:')) {
        return uri;
      }

      return base.substr(0, base.lastIndexOf('/') + 1) + uri;
    } // Start loading linked assets

  }, {
    key: "_loadLinkedAssets",
    value: function _loadLinkedAssets(options) {
      var _this2 = this;

      var promises = [];

      if (!this.glbParser) {
        this.gltf.buffers.forEach(function (buffer) {
          // TODO: handle base64 encoded files in the non-async path
          if (buffer.uri) {
            // TODO: Use loaders.gl readFile API so that this works on node.js as well
            promises.push(window.fetch(_this2._getFullUri(buffer.uri, options.uri)).then(function (res) {
              return res.arrayBuffer();
            }).then(function (data) {
              buffer.data = data;
            }));
          }
        });
      }

      return Promise.all(promises);
    }
  }, {
    key: "_postProcessGLTF",
    value: function _postProcessGLTF() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // Create all images (if requested)
      this.out.images = (this.gltf.images || []).map(function (image) {
        return _this3.parseImage(image, options);
      }).filter(Boolean); // Normalize all scenes

      this.out.scenes = (this.gltf.scenes || []).map(function (scene) {
        return _this3.parseScene(scene, options);
      }).filter(Boolean);

      if (this.gltf.scene !== undefined) {
        this.out.scene = this.gltf.scenes[this.gltf.scene];
      }

      return this;
    } // Convert indexed glTF structure into tree structure
    // PREPARATION STEP: CROSS-LINK INDEX RESOLUTION, ENUM LOOKUP, CONVENIENCE CALCULATIONS

    /* eslint-disable complexity */

  }, {
    key: "_resolveToTree",
    value: function _resolveToTree() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var gltf = this.gltf;
      (gltf.bufferViews || []).forEach(function (bufView, i) {
        return _this4._resolveBufferView(bufView, i);
      });
      (gltf.images || []).forEach(function (image, i) {
        return _this4._resolveImage(image, i, options);
      });
      (gltf.samplers || []).forEach(function (sampler, i) {
        return _this4._resolveSampler(sampler, i);
      });
      (gltf.textures || []).forEach(function (texture, i) {
        return _this4._resolveTexture(texture, i);
      });
      (gltf.accessors || []).forEach(function (accessor, i) {
        return _this4._resolveAccessor(accessor, i);
      });
      (gltf.materials || []).forEach(function (material, i) {
        return _this4._resolveMaterial(material, i);
      });
      (gltf.meshes || []).forEach(function (mesh, i) {
        return _this4._resolveMesh(mesh, i);
      });
      (gltf.nodes || []).forEach(function (node, i) {
        return _this4._resolveNode(node, i);
      });
      (gltf.skins || []).forEach(function (skin, i) {
        return _this4._resolveSkin(skin, i);
      });
      (gltf.scenes || []).forEach(function (scene, i) {
        return _this4._resolveScene(scene, i);
      });

      if (gltf.scene !== undefined) {
        gltf.scene = gltf.scenes[this.gltf.scene];
      }

      return gltf;
    }
    /* eslint-enable complexity */

  }, {
    key: "_resolveScene",
    value: function _resolveScene(scene, index) {
      var _this5 = this;

      scene.id = "scene-".concat(index);
      scene.nodes = (scene.nodes || []).map(function (node) {
        return _this5.getNode(node);
      });
    }
  }, {
    key: "_resolveNode",
    value: function _resolveNode(node, index) {
      var _this6 = this;

      node.id = "node-".concat(index);
      node.children = (node.children || []).map(function (child) {
        return _this6.getNode(child);
      });

      if (node.mesh !== undefined) {
        node.mesh = this.getMesh(node.mesh);
      }

      if (node.camera !== undefined) {
        node.camera = this.getCamera(node.camera);
      }

      if (node.skin !== undefined) {
        node.skin = this.getSkin(node.skin);
      }
    }
  }, {
    key: "_resolveSkin",
    value: function _resolveSkin(skin, index) {
      skin.id = "skin-".concat(index);
      skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);
    }
  }, {
    key: "_resolveMesh",
    value: function _resolveMesh(mesh, index) {
      mesh.id = "mesh-".concat(index);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = mesh.primitives[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var primitive = _step2.value;

          for (var attribute in primitive.attributes) {
            primitive.attributes[attribute] = this.getAccessor(primitive.attributes[attribute]);
          }

          if (primitive.indices !== undefined) {
            primitive.indices = this.getAccessor(primitive.indices);
          }

          if (primitive.material !== undefined) {
            primitive.material = this.getMaterial(primitive.material);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "_resolveMaterial",
    value: function _resolveMaterial(material, index) {
      material.id = "material-".concat(index);

      if (material.normalTexture) {
        material.normalTexture.texture = this.getTexture(material.normalTexture.index);
      }

      if (material.occlusionTexture) {
        material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
      }

      if (material.emissiveTexture) {
        material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
      }

      if (material.pbrMetallicRoughness) {
        var mr = material.pbrMetallicRoughness;

        if (mr.baseColorTexture) {
          mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
        }

        if (mr.metallicRoughnessTexture) {
          mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
        }
      }
    }
  }, {
    key: "_resolveAccessor",
    value: function _resolveAccessor(accessor, index) {
      accessor.id = "accessor-".concat(index);
      accessor.bufferView = this.getBufferView(accessor.bufferView); // Look up enums

      accessor.bytesPerComponent = (0, _gltfTypeUtils.getBytesFromComponentType)(accessor);
      accessor.components = (0, _gltfTypeUtils.getSizeFromAccessorType)(accessor);
      accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;
    }
  }, {
    key: "_resolveTexture",
    value: function _resolveTexture(texture, index) {
      texture.id = "texture-".concat(index);
      texture.sampler = this.getSampler(texture.sampler);
      texture.source = this.getImage(texture.source);
    }
  }, {
    key: "_resolveSampler",
    value: function _resolveSampler(sampler, index) {
      sampler.id = "sampler-".concat(index); // Map textual parameters to GL parameter values

      sampler.parameters = {};

      for (var key in sampler) {
        var glEnum = this._enumSamplerParameter(key);

        if (glEnum !== undefined) {
          sampler.parameters[glEnum] = sampler[key];
        }
      }
    }
  }, {
    key: "_enumSamplerParameter",
    value: function _enumSamplerParameter(key) {
      return SAMPLER_PARAMETER_GLTF_TO_GL[key];
    }
  }, {
    key: "_resolveImage",
    value: function _resolveImage(image, index, options) {
      var _this7 = this;

      image.id = "image-".concat(index);

      if (image.bufferView !== undefined) {
        image.bufferView = this.getBufferView(image.bufferView);
      } // TODO - Handle non-binary-chunk images, data URIs, URLs etc
      // TODO - Image creation could be done on getImage instead of during load


      var _options$createImages = options.createImages,
          createImages = _options$createImages === void 0 ? true : _options$createImages;

      if (createImages) {
        image.image = this.glbParser.getImage(image);
      } else {
        image.getImageAsync = function () {
          if (_this7.glbParser) {
            return _this7.glbParser.getImageAsync(image);
          } else if (image.uri) {
            // TODO: Maybe just return the URL?
            // TODO: Maybe use loaders.gl/core loadImage?
            return new Promise(function (resolve) {
              /* global Image */
              var img = new Image();
              img.crossOrigin = 'anonymous';

              img.onload = function () {
                return resolve(img);
              };

              img.src = _this7._getFullUri(image.uri, options.uri);
            });
          } // cannot get image


          return null;
        };
      }
    }
  }, {
    key: "_resolveBufferView",
    value: function _resolveBufferView(bufferView, index) {
      bufferView.id = "bufferView-".concat(index);
      bufferView.buffer = this.getBuffer(bufferView.buffer);

      if (this.glbParser) {
        bufferView.data = this.glbParser.getBufferView(bufferView);
      } else {
        var byteOffset = bufferView.byteOffset || 0;
        bufferView.data = new Uint8Array(bufferView.buffer.data, byteOffset, bufferView.byteLength);
      }
    }
  }, {
    key: "_decompressUberDracoPointCloud",
    value: function _decompressUberDracoPointCloud(primitive, extensions) {
      var bufferViewIndex = extensions.UBER_draco_point_cloud_compression.bufferView;
      var bufferView = this.getBufferView(bufferViewIndex); // TODO: change to getArrayFromBufferView()

      var compressedData = this.glbParser.getBufferView(bufferView);
      var dracoDecoder = new this.DracoDecoder();
      var decodedPrimitive = dracoDecoder.decode(compressedData); // TODO: what to do about original attributes

      primitive.attributes = decodedPrimitive.attributes; // TODO: stashing header on primitive, not sure if necessary

      primitive.header = decodedPrimitive.header; // TODO: drawmode is currently undefined, look into dracodecoder to set to 0 for point cloud

      primitive.drawMode = decodedPrimitive.drawMode || 0;
    } // PREPROC

  }, {
    key: "_resolveCamera",
    value: function _resolveCamera(camera) {
      // TODO - create 4x4 matrices
      if (camera.perspective) {// camera.matrix = createPerspectiveMatrix(camera.perspective);
      }

      if (camera.orthographic) {// camera.matrix = createOrthographicMatrix(camera.orthographic);
      }
    }
  }]);
  return GLTFParser;
}();

exports.default = GLTFParser;
//# sourceMappingURL=gltf-parser.js.map