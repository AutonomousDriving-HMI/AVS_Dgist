function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* global setTimeout, clearTimeout, document */
import React from 'react';
import PropTypes from 'prop-types';
import Popper from 'popper.js';
import styled from '@emotion/styled';
import { withTheme, evaluateStyle } from '../theme';
import { capitalize, getOppositePosition, generateTriangleStyles, nodeHasParent, positionsToPopperPlacement } from './utils';
const isBrowser = typeof document !== 'undefined' && Boolean(document.createElement);
export const POSITIONS = {
  TOP: 'top',
  RIGHT: 'right',
  BOTTOM: 'bottom',
  LEFT: 'left',
  AUTO: 'auto'
};
export const TRIGGERS = {
  CLICK: 'click',
  HOVER: 'hover'
};
const DEFAULT_ARROW_SIZE = 6;
const DEFAULT_BORDER_WIDTH = 1;
const PopoverComponent = styled.div(props => _objectSpread({
  /* Default wrapper style should ideally be display: inline so that popover
  shows directly beneath child content, inline-flex just generally works
  better than inline */
  display: 'inline-flex'
}, evaluateStyle(props.userStyle, props)));
const PopoverTarget = styled.div(props => _objectSpread({}, evaluateStyle(props.userStyle, props)));
const PopoverContent = styled.div(props => _objectSpread({}, evaluateStyle(props.userStyle, props)));
const PopoverBody = styled.div(props => {
  let style = null;

  if (props.position && props.position !== POSITIONS.AUTO && props.arrowSize) {
    style = {
      [`margin${capitalize(getOppositePosition(props.position))}`]: props.arrowSize
    };
  }

  return _objectSpread({}, props.theme.__reset__, style, {
    position: 'absolute',
    top: 0,
    left: 0,
    zIndex: 99,
    background: props.background || props.theme.background,
    borderStyle: 'solid',
    borderWidth: props.borderWidth,
    borderColor: props.borderColor || props.theme.controlColorPrimary,
    boxShadow: props.theme.shadow,
    fontFamily: props.theme.fontFamily,
    fontSize: props.theme.fontSize,
    fontWeight: 'normal'
  }, props.popperStyles, evaluateStyle(props.userStyle, props));
});
const OuterArrow = styled.div(props => {
  /**
   * We create our arrow triangle using css borders, however this makes it
   * difficult for us to add an actual border effect to the triangle. In order
   * to achieve this effect, we generate two arrows and overlap themâ€“an outer
   * arrow with the border color, and an inner arrow with the background color.
   */
  const position = props.position,
        arrowSize = props.arrowSize,
        popperOffsets = props.popperOffsets;

  if (!arrowSize) {
    return null;
  }

  const arrowOffsets = popperOffsets.arrow || {};
  const style = {
    borderColor: props.borderColor || props.theme.controlColorPrimary,
    // Position the arrow to hang off the edge of the popover
    // For example, a left-facing arrow would need the rule right: -{size}px
    [getOppositePosition(position)]: -arrowSize
  }; // Now apply arrow offsets calculated by popper library (if needed)

  if (arrowOffsets.top) {
    style.top = arrowOffsets.top;
  }

  if (arrowOffsets.left) {
    style.left = arrowOffsets.left;
  }

  return Object.assign(style, evaluateStyle(props.userStyle, props), generateTriangleStyles(position, arrowSize));
});
const InnerArrow = styled.div(props => {
  const position = props.position,
        arrowSize = props.arrowSize;

  if (!arrowSize) {
    return null;
  }

  const isVertical = position === POSITIONS.TOP || position === POSITIONS.BOTTOM;
  const style = {
    borderColor: props.background || props.theme.background
  }; // Offset the inner arrow a couple pixels from its parent (the outer arrow)

  if (isVertical) {
    style.left = -arrowSize;
    style.top = position === POSITIONS.TOP ? -arrowSize : 0;
    style.marginTop = (position === POSITIONS.TOP ? -1 : 1) * props.borderWidth;
  } else {
    style.top = -arrowSize;
    style.left = position === POSITIONS.LEFT ? -arrowSize : 0;
    style.marginLeft = (position === POSITIONS.LEFT ? -1 : 1) * props.borderWidth;
  }

  return Object.assign(style, evaluateStyle(props.userStyle, props), generateTriangleStyles(position, arrowSize));
});
const POSITIONS_PROP_TYPE = PropTypes.oneOf([POSITIONS.TOP, POSITIONS.RIGHT, POSITIONS.BOTTOM, POSITIONS.LEFT, POSITIONS.AUTO]);

class Popover extends React.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "_handleTargetClick", () => {
      this._togglePopover();
    });

    _defineProperty(this, "_handleTargetMouseEnter", () => {
      // If onMouseOutDelay is set and mouse is moving from popper back to target,
      // we want to cancel any timers that would cause it to hide unexpectedly
      clearTimeout(this.hideTimer);

      this._showPopover();
    });

    _defineProperty(this, "_handleTargetMouseLeave", () => {
      this._hidePopoverWithDelay();
    });

    _defineProperty(this, "_handlePopoverMouseEnter", () => {
      clearTimeout(this.hideTimer);
    });

    _defineProperty(this, "_handlePopoverMouseLeave", () => {
      this._hidePopoverWithDelay();
    });

    _defineProperty(this, "_handleKeyPress", evt => {
      if (evt.key === 'Escape') {
        this._hidePopover();
      }
    });

    _defineProperty(this, "_handlePopperUpdate", data => {
      this.setState({
        popperOffsets: data.offsets,
        popperPlacement: data.placement,
        popperStyles: data.styles
      });
      return data;
    });

    _defineProperty(this, "_hidePopover", () => {
      this.setState(this._getDefaultState(this.props));

      this._destroyPopover();
    });

    _defineProperty(this, "_handleDocumentClick", evt => {
      if (!this.$popper || nodeHasParent(evt.target, this.$popper) || nodeHasParent(evt.target, this.$target)) {
        return;
      }

      this._hidePopover();
    });

    this.state = this._getDefaultState(props);
  }

  componentDidUpdate(prevProps, prevState) {
    // If we just switched to showing popover, create a new Popper for positioning
    if (this.state.isVisible && !prevState.isVisible) {
      const PopperClass = this.props.popperClass;
      this.popper = new PopperClass(this.$target, this.$popper, {
        placement: this.state.popperPlacement,
        modifiers: {
          // Passing the arrow ref will measure the arrow when calculating styles
          arrow: {
            element: this.$arrow,
            enabled: true
          },
          // Disable default styling modifier, and use our custom react one instead
          applyStyle: {
            enabled: false
          },
          applyReactStyle: {
            enabled: true,
            fn: this._handlePopperUpdate,
            order: 900
          }
        }
      });

      if (this.props.trigger === TRIGGERS.CLICK) {
        this._addClickEvents();
      }
    }
  }

  componentWillUnmount() {
    this._destroyPopover();

    this._removeClickEvents();
  }

  _getDefaultState(props) {
    return {
      isVisible: false,
      popperOffsets: {},
      popperPlacement: positionsToPopperPlacement(props.position, props.arrowPosition),
      popperStyles: {}
    };
  }

  _showPopover() {
    this.setState({
      isVisible: true
    });
  }

  _hidePopoverWithDelay() {
    const onMouseOutDelay = this.props.onMouseOutDelay;

    if (onMouseOutDelay) {
      this.hideTimer = setTimeout(this._hidePopover, onMouseOutDelay);
      return;
    }

    this._hidePopover();
  }

  _addClickEvents() {
    if (!isBrowser) {
      return;
    }

    document.addEventListener('mousedown', this._handleDocumentClick);
    document.addEventListener('keyup', this._handleKeyPress);
  }

  _removeClickEvents() {
    if (!isBrowser) {
      return;
    }

    document.removeEventListener('mousedown', this._handleDocumentClick);
    document.removeEventListener('keyup', this._handleKeyPress);
  }

  _togglePopover() {
    const isVisible = !this.state.isVisible;
    this.setState({
      isVisible
    });

    if (!isVisible) {
      this._destroyPopover();
    }
  }

  _destroyPopover() {
    if (this.popper) {
      this.popper.destroy();
      delete this.popper;
    }

    if (this.props.trigger === TRIGGERS.CLICK) {
      this._removeClickEvents();
    }
  }

  _renderTarget(styleProps) {
    const _this$props = this.props,
          trigger = _this$props.trigger,
          style = _this$props.style;
    const interactionProps = {};

    if (trigger === TRIGGERS.HOVER) {
      interactionProps.onMouseEnter = this._handleTargetMouseEnter;
      interactionProps.onMouseLeave = this._handleTargetMouseLeave;
    } else if (trigger === TRIGGERS.CLICK) {
      interactionProps.onClick = this._handleTargetClick;
    }

    return React.createElement(PopoverTarget, _extends({}, interactionProps, {
      userStyle: style.target
    }, styleProps, {
      ref: el => {
        this.$target = el;
      }
    }), this.props.children);
  }

  _renderArrow(styleProps) {
    const style = this.props.style;
    return React.createElement(OuterArrow, _extends({
      userStyle: style.arrowBorder
    }, styleProps, {
      ref: el => {
        this.$arrow = el;
      }
    }), React.createElement(InnerArrow, _extends({
      userStyle: style.arrow
    }, styleProps)));
  }

  _renderBody(styleProps) {
    const _this$props2 = this.props,
          className = _this$props2.className,
          style = _this$props2.style,
          trigger = _this$props2.trigger;
    const interactionProps = {};

    if (trigger === TRIGGERS.HOVER) {
      interactionProps.onMouseEnter = this._handlePopoverMouseEnter;
      interactionProps.onMouseLeave = this._handlePopoverMouseLeave;
    }

    return React.createElement(PopoverBody, _extends({
      className: className
    }, interactionProps, {
      userStyle: style.body
    }, styleProps, {
      ref: el => {
        this.$popper = el;
      }
    }), this._renderContent(styleProps), this._renderArrow(styleProps));
  }

  _renderContent(styleProps) {
    const content = typeof this.props.content === 'function' ? this.props.content() : this.props.content;
    return React.createElement(PopoverContent, _extends({
      userStyle: this.props.style.content
    }, styleProps), content);
  }

  render() {
    const _this$props3 = this.props,
          theme = _this$props3.theme,
          style = _this$props3.style;
    const _this$state = this.state,
          isVisible = _this$state.isVisible,
          popperPlacement = _this$state.popperPlacement,
          popperStyles = _this$state.popperStyles,
          popperOffsets = _this$state.popperOffsets;

    const _popperPlacement$spli = popperPlacement.split('-'),
          _popperPlacement$spli2 = _slicedToArray(_popperPlacement$spli, 1),
          position = _popperPlacement$spli2[0];

    const arrowPosition = position === POSITIONS.AUTO ? POSITIONS.TOP : position;
    const styleProps = {
      theme,
      arrowSize: 'arrowSize' in style ? style.arrowSize : DEFAULT_ARROW_SIZE,
      background: style.background,
      borderWidth: 'borderWidth' in style ? style.borderWidth : DEFAULT_BORDER_WIDTH,
      borderColor: style.borderColor,
      position,
      arrowPosition,
      popperStyles,
      popperOffsets,
      isActive: isVisible
    };
    return React.createElement(PopoverComponent, _extends({
      userStyle: style.popover
    }, styleProps), this._renderTarget(styleProps), isVisible && this._renderBody(styleProps));
  }

}

_defineProperty(Popover, "propTypes", {
  className: PropTypes.string,
  style: PropTypes.object,
  content: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,
  position: POSITIONS_PROP_TYPE,
  // Arrow options
  arrowPosition: POSITIONS_PROP_TYPE,
  // Interaction
  onMouseOutDelay: PropTypes.number,
  trigger: PropTypes.oneOf([TRIGGERS.HOVER, TRIGGERS.CLICK]),
  // Support injecting mock Popper class for tests
  popperClass: PropTypes.func
});

_defineProperty(Popover, "defaultProps", {
  className: '',
  style: {},
  trigger: TRIGGERS.CLICK,
  onMouseOutDelay: 0,
  popperClass: Popper
});

const ThemedPopover = withTheme(Popover);
Object.assign(ThemedPopover, POSITIONS);
Object.assign(ThemedPopover, TRIGGERS);
export default ThemedPopover;
//# sourceMappingURL=popover.js.map