"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseStreamVideoMessage = parseStreamVideoMessage;
exports.parseStreamVideoData = parseStreamVideoData;
exports.parseVideoFrame = parseVideoFrame;

var _constants = require("../constants");

var _textEncoding = require("../utils/text-encoding");

var _binary = require("../utils/binary");

var _parseLogMetadata = require("./parse-log-metadata");

// Copyright (c) 2019 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * This file contains parsers for XVIZ video stream protocol.
 * Naming conventions:
 * `message` refers to the raw message received via webSocket.onmessage
 * `data` refers to pre-processed data objects (blob, arraybuffer, JSON object)
 */

/* global Blob */
// Handle messages from the stand alone video server
function parseStreamVideoMessage(message, onResult, onError) {
  if (message instanceof Blob) {
    (0, _binary.blobToArrayBuffer)(message).then(function (arrayBuffer) {
      parseStreamVideoMessage(arrayBuffer, onResult, onError);
    }).catch(onError);
    return;
  }

  try {
    var data = message;

    if (typeof message === 'string') {
      data = JSON.parse(message);
    }

    var result = parseStreamVideoData(data);
    onResult(result);
  } catch (error) {
    onError(error);
  }
} // Handle messages from the stand alone video server


function parseStreamVideoData(data) {
  if (data instanceof ArrayBuffer) {
    return parseVideoFrame(data);
  }

  if (data.type === 'metadata') {
    return parseVideoMetadata(data);
  } // Unknown message


  return {
    type: _constants.LOG_STREAM_MESSAGE.ERROR,
    message: 'Unknown stream data type',
    data: data
  };
} // Extract metadata from stream message


function parseVideoMetadata(data) {
  var result = (0, _parseLogMetadata.parseLogMetadata)(data);
  result.type = _constants.LOG_STREAM_MESSAGE.VIDEO_METADATA;
  return result;
} // Parse image data from stream message
// https://code.int.uberatc.com/diffusion/AV/browse/master/source/xviz/services/video/www/index.js


function parseVideoFrame(arrayBuffer) {
  var view = new DataView(arrayBuffer); // Read off version

  var result = {
    type: _constants.LOG_STREAM_MESSAGE.VIDEO_FRAME
  };
  var littleEndian = true;
  var utf8Decoder = new _textEncoding.TextDecoder('utf-8'); // Check version

  var offset = 0;
  result.version = view.getUint32(offset, littleEndian);
  offset += 4;
  result.versionFlags = view.getUint32(offset, littleEndian);
  offset += 4; // Read off stream name

  var streamLength = view.getUint32(offset, littleEndian);
  var stringStart = offset + 4;
  offset += 4 + streamLength;
  result.stream = utf8Decoder.decode(arrayBuffer.slice(stringStart, offset)); // Read off timestamp

  result.timestamp = view.getFloat64(offset, littleEndian);
  offset += 8; // Read slice off the image data

  var imageSize = view.getUint32(offset, littleEndian);
  offset += 4;
  result.imageData = arrayBuffer.slice(offset, offset + imageSize);
  result.imageType = 'image/jpeg';
  return result;
}
//# sourceMappingURL=parse-stream-video-message.js.map