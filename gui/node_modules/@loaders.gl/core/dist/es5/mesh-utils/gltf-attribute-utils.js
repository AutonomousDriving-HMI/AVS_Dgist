"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGLTFIndices = getGLTFIndices;
exports.getGLTFAccessors = getGLTFAccessors;
exports.getGLTFAttributeMap = getGLTFAttributeMap;
exports.getGLTFAccessor = getGLTFAccessor;
exports.getGLTFAttribute = getGLTFAttribute;

var _gltfTypeUtils = require("./gltf-type-utils");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

// Patters that map known names to GLTF counterparts
var POSITION = 'POSITION';
var TEXCOORD_0 = 'TEXCOORD_0';
var TEXCOORD_1 = 'TEXCOORD_1';
var TEXCOORD_2 = 'TEXCOORD_2';
var ATTRIBUTE_PATTERNS = [[/color/i, 'COLOR_0'], [/pickingColor/i, 'COLOR_1'], [/normal/i, 'NORMAL'], [/tangent/i, 'TANGENT'], [/texCoord1/i, TEXCOORD_0], [/texCoord2/i, TEXCOORD_1], [/texCoord3/i, TEXCOORD_2], [/texCoord/i, TEXCOORD_0], [/uv1/i, TEXCOORD_0], [/uv2/i, TEXCOORD_1], [/uv3/i, TEXCOORD_2], [/uv/i, TEXCOORD_0], [/joints/i, 'JOINTS_0'], [/weights/i, 'WEIGHTS_0'], [/pos/i, POSITION], [/vertex/i, POSITION], [/vertices/i, POSITION]]; // Returns the indices array, if present

function getGLTFIndices(attributes) {
  for (var name in attributes) {
    var attribute = attributes[name];

    if (isGLTFIndices(name)) {
      var indices = toTypedArray(attribute, Uint32Array);
      return getGLTFAccessor(indices);
    }
  }

  return null;
} // Returns a fresh attributes object with glTF-standardized attributes names
// Attributes that cannot be identified will not be included
// Removes `indices` if present, as it should be stored separately from the attributes


function getGLTFAccessors(attributes) {
  var accessors = {};

  for (var name in attributes) {
    var attribute = attributes[name];

    if (!isGLTFIndices(name)) {
      var glTFAccessor = getGLTFAccessor(attribute);
      accessors[name] = glTFAccessor;
    }
  }

  return accessors;
} // Returns an object with a map from glTF-standardized attributes names to loaded attribute names


function getGLTFAttributeMap(attributes) {
  var standardizedAttributes = {};

  for (var name in attributes) {
    var standardizedName = getGLTFAttributeName(name);

    if (standardizedName && !isGLTFIndices(name)) {
      standardizedAttributes[standardizedName] = name;
    }
  }

  return standardizedAttributes;
} // Fix up a single accessor.
// Input: typed array or a partial accessor object
// Return: accessor object


function getGLTFAccessor(attribute, gltfAttributeName) {
  var _getAccessorData = getAccessorData(attribute, gltfAttributeName),
      buffer = _getAccessorData.buffer,
      size = _getAccessorData.size,
      count = _getAccessorData.count;

  var glTFAccessor = {
    // TODO: Deprecate `value` in favor of bufferView?
    value: buffer,
    size: size,
    // Decoded `type` (e.g. SCALAR)
    // glTF Accessor values
    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)
    bufferView: null,
    byteOffset: 0,
    count: count,
    type: (0, _gltfTypeUtils.getAccessorTypeFromSize)(size),
    componentType: (0, _gltfTypeUtils.getComponentTypeFromArray)(buffer)
  };
  return glTFAccessor;
}

function getGLTFAttribute(data, gltfAttributeName) {
  return data.attributes[data.glTFAttributeMap[gltfAttributeName]];
} // Check if an attribute contains indices


function isGLTFIndices(name) {
  name = name.toLowerCase();
  return name.indexOf('index') !== -1 || name.indexOf('indices') !== -1 || name.indexOf('element') !== -1;
} // Convert an attribute name string to glTF 2.0 recommended attribute names
// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#geometry


function getGLTFAttributeName(name) {
  name = name.toLowerCase();

  for (var _i = 0; _i < ATTRIBUTE_PATTERNS.length; _i++) {
    var _ATTRIBUTE_PATTERNS$_ = _slicedToArray(ATTRIBUTE_PATTERNS[_i], 2),
        regex = _ATTRIBUTE_PATTERNS$_[0],
        standardizedName = _ATTRIBUTE_PATTERNS$_[1];

    if (regex.exec(name)) {
      return standardizedName;
    }
  }

  return null;
}

function getAccessorData(attribute, attributeName) {
  var buffer = attribute;
  var size = 1;
  var count = 0;

  if (attribute && attribute.value) {
    buffer = attribute.value;
    size = attribute.size || 1;
  }

  if (buffer) {
    if (!ArrayBuffer.isView(buffer)) {
      buffer = toTypedArray(buffer, Float32Array);
    }

    count = buffer.length / size;
  }

  return {
    buffer: buffer,
    size: size,
    count: count
  };
} // Convert non-typed arrays to arrays of specified format


function toTypedArray(array, ArrayType) {
  var convertTypedArrays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (!array) {
    return null;
  }

  if (Array.isArray(array)) {
    return new ArrayType(array);
  }

  if (convertTypedArrays && !(array instanceof ArrayType)) {
    return new ArrayType(array);
  }

  return array;
}
//# sourceMappingURL=gltf-attribute-utils.js.map