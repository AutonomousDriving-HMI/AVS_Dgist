function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

// Copyright (c) 2019 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Extracts a TIMESLICE message v2
import { LOG_STREAM_MESSAGE } from '../constants';
import { getXVIZConfig } from '../config/xviz-config';
import { parseXVIZPose } from './parse-xviz-pose';
import { parseStreamFutures, parseStreamPrimitive, parseStreamVariable, parseStreamTimeSeries, parseStreamUIPrimitives } from './parse-xviz-stream';
import log from '../utils/log';
/* eslint-disable camelcase */

export default function parseStreamSet(data, convertPrimitive) {
  var update_type = data.update_type,
      updates = data.updates;

  if (update_type !== 'snapshot') {
    log.error("Only XVIZ update_type of \"snapshot\" is currently supported. Type \"".concat(update_type, "\" is not supported."))();
    return {
      type: LOG_STREAM_MESSAGE.INCOMPLETE,
      message: 'Unsupported update type'
    };
  }

  if (!updates) {
    return {
      type: LOG_STREAM_MESSAGE.INCOMPLETE,
      message: 'Missing required "updates" property'
    };
  }

  if (updates && updates.length === 0) {
    return {
      type: LOG_STREAM_MESSAGE.INCOMPLETE,
      message: 'Property "updates" has length of 0, no data?'
    };
  }

  if (updates.length > 1) {
    log.warn("Only XVIZ first update of \"snapshot\" is currently supported. Current updates has \"".concat(updates.length, "\" entries."))();
  }

  var streamSets = updates;
  var timestamp = null;

  if (!timestamp && streamSets) {
    timestamp = streamSets.reduce(function (t, stateUpdate) {
      return Math.max(t, stateUpdate.timestamp);
    }, 0);
  }

  if (!timestamp) {
    // Incomplete stream message, just tag it accordingly so client can ignore it
    return {
      type: LOG_STREAM_MESSAGE.INCOMPLETE,
      message: 'Missing timestamp in "updates"'
    };
  }

  var newStreams = {};
  var result = {
    type: LOG_STREAM_MESSAGE.TIMESLICE,
    streams: newStreams,
    timestamp: timestamp // TODO/Xintong validate primary vehicle pose in each update?

  };

  if (streamSets) {
    var xvizStreams = parseStreamSets(streamSets, timestamp, convertPrimitive);
    Object.assign(newStreams, xvizStreams);
  }

  return result;
}
/* eslint-disable max-statements */

function parseStreamSets(streamSets, timestamp, convertPrimitive) {
  var _getXVIZConfig = getXVIZConfig(),
      STREAM_BLACKLIST = _getXVIZConfig.STREAM_BLACKLIST;

  var newStreams = {};
  var poses = {};
  var primitives = {};
  var variables = {};
  var timeSeries = [];
  var futures = {};
  var uiPrimitives = {};
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = streamSets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var streamSet = _step.value;
      Object.assign(poses, streamSet.poses);
      Object.assign(primitives, streamSet.primitives);
      Object.assign(variables, streamSet.variables);
      Object.assign(futures, streamSet.future_instances);
      Object.assign(uiPrimitives, streamSet.ui_primitives);

      if (streamSet.time_series) {
        if (timeSeries) {
          timeSeries.push.apply(timeSeries, _toConsumableArray(streamSet.time_series));
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  Object.keys(poses).filter(function (streamName) {
    return !STREAM_BLACKLIST.has(streamName);
  }).forEach(function (streamName) {
    newStreams[streamName] = parseXVIZPose(poses[streamName]);
  });
  Object.keys(primitives).filter(function (streamName) {
    return !STREAM_BLACKLIST.has(streamName);
  }).forEach(function (primitive) {
    newStreams[primitive] = parseStreamPrimitive(primitives[primitive], primitive, timestamp, convertPrimitive);
  });
  Object.keys(variables).filter(function (streamName) {
    return !STREAM_BLACKLIST.has(streamName);
  }).forEach(function (variable) {
    newStreams[variable] = parseStreamVariable(variables[variable], variable, timestamp);
  });

  if (timeSeries.length) {
    var timeSeriesStreams = parseStreamTimeSeries(timeSeries, STREAM_BLACKLIST);
    Object.assign(newStreams, timeSeriesStreams);
  }

  Object.keys(futures).filter(function (streamName) {
    return !STREAM_BLACKLIST.has(streamName);
  }).forEach(function (future) {
    newStreams[future] = parseStreamFutures(futures[future], future, timestamp, convertPrimitive);
  });
  Object.keys(uiPrimitives).filter(function (streamName) {
    return !STREAM_BLACKLIST.has(streamName);
  }).forEach(function (primitive) {
    newStreams[primitive] = parseStreamUIPrimitives(uiPrimitives[primitive], primitive, timestamp);
  });
  return newStreams;
}
/* eslint-enable max-statements */
//# sourceMappingURL=parse-timeslice-data-v2.js.map