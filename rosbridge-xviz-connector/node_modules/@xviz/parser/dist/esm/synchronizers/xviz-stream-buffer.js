function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Copyright (c) 2019 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import XVIZObject from '../objects/xviz-object';
import assert from '../utils/assert';
import { findInsertPos, INSERT_POSITION } from '../utils/search'; // Insert positions

var LEFT = INSERT_POSITION.LEFT;
var RIGHT = INSERT_POSITION.RIGHT; // Buffer types

var UNLIMITED = 0;
var OFFSET = 1;
var FIXED = 2;

var XVIZStreamBuffer =
/*#__PURE__*/
function () {
  /**
   * constructor
   * @param {object} options
   * @param {number} options.startOffset - desired start of buffer to keep in memory
   *  relative to the current time.
   * @param {number} options.endOffset - desired end of buffer to keep in memory
   *  relative to the current time.
   */
  function XVIZStreamBuffer() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$startOffset = _ref.startOffset,
        startOffset = _ref$startOffset === void 0 ? null : _ref$startOffset,
        _ref$endOffset = _ref.endOffset,
        endOffset = _ref$endOffset === void 0 ? null : _ref$endOffset,
        _ref$maxLength = _ref.maxLength,
        maxLength = _ref$maxLength === void 0 ? null : _ref$maxLength;

    _classCallCheck(this, XVIZStreamBuffer);

    if (Number.isFinite(startOffset) && Number.isFinite(endOffset)) {
      assert(startOffset <= 0 && endOffset >= 0, 'Steam buffer offset');
      this.bufferType = OFFSET;
    } else {
      this.bufferType = UNLIMITED;
    }

    this.options = {
      startOffset: startOffset,
      endOffset: endOffset,
      maxLength: maxLength
    };
    /* Desired buffer range, in timestamps */

    this.bufferStart = null;
    this.bufferEnd = null;
    /* Sorted timeslices */

    this.timeslices = [];
    /* Sorted values by stream */

    this.streams = {};
    this.videos = {};
    /* Update counter */

    this.lastUpdate = 0;
    this.hasBuffer = this.hasBuffer.bind(this);
  }
  /**
   * @property {number} the count of timeslices in buffer
   */


  _createClass(XVIZStreamBuffer, [{
    key: "updateFixedBuffer",

    /**
     * updates the fixed buffer range, capping it to maxLength if set
     * @param {number} start - desired fixed start time of buffer to keep in memory
     * @param {number} end - desired fixed end time of buffer to keep in memory
     * @returns {start: number, end: number, oldStart: number, oldEnd: number} - the old and new buffer ranges
     */
    value: function updateFixedBuffer(start, end) {
      var bufferStart = this.bufferStart,
          bufferEnd = this.bufferEnd,
          maxLength = this.options.maxLength;
      assert(start < end, 'updateFixedBuffer start / end');
      assert(this.bufferType === UNLIMITED || this.bufferType === FIXED, 'updateFixedBuffer multiple buffer types');
      this.bufferType = FIXED;

      if (!maxLength) {
        // If we have no limits on buffer size, just use the new provided values
        this.bufferStart = start;
        this.bufferEnd = end;
      } else if (!Number.isFinite(bufferStart) || start > bufferEnd + maxLength || start < bufferStart - maxLength) {
        // If we have a limit but this is our first range definition, or this is so far before the existing
        // buffer that there's no overlap, use the provided start and determine end based on max buffer length
        this.bufferStart = start;
        this.bufferEnd = Math.min(end, start + maxLength);
      } else if (start < bufferStart) {
        // If this is before the existing buffer but close enough to have overlap, use the provided start
        // and determine the end based on max buffer length and the existing buffer end
        this.bufferStart = start;
        this.bufferEnd = Math.min(bufferEnd, start + maxLength);
      } else {
        // Otherwise, we're past the end of the existing buffer and either extend the existing buffer
        // or start a new buffer based on maxLength
        this.bufferStart = Math.min(bufferEnd, end - maxLength);
        this.bufferEnd = Math.min(this.bufferStart + maxLength, end);
      }

      this._pruneBuffer();

      return {
        start: this.bufferStart,
        end: this.bufferEnd,
        oldStart: bufferStart,
        oldEnd: bufferEnd
      };
    }
    /**
     * Gets the time range that the buffer is accepting data for
     * @returns {object} - {start | null, end | null} timestamps if any timeslice is loaded
     */

  }, {
    key: "getBufferRange",
    value: function getBufferRange() {
      if (this.bufferType !== UNLIMITED) {
        var bufferStart = this.bufferStart,
            bufferEnd = this.bufferEnd;

        if (Number.isFinite(bufferStart)) {
          // buffer range should be ignored if setCurrentTime has not been called
          return {
            start: bufferStart,
            end: bufferEnd
          };
        }
      }

      return {
        start: null,
        end: null
      };
    }
    /**
     * Gets the buffered time range
     * @returns {object | null} - {start, end} timestamps if any timeslice is loaded
     */

  }, {
    key: "getLoadedTimeRange",
    value: function getLoadedTimeRange() {
      var timeslices = this.timeslices;
      var len = timeslices.length;

      if (len > 0) {
        return {
          start: timeslices[0].timestamp,
          end: timeslices[len - 1].timestamp
        };
      }

      return null;
    }
    /**
     * Gets timeslices within a given time range.
     * @params {number, optional} start - start timestamp (inclusive)
     * @params {number, optional} end - end timestamp (inclusive)
     * @returns {array} - loaded timeslices within range
     */

  }, {
    key: "getTimeslices",
    value: function getTimeslices() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          start = _ref2.start,
          end = _ref2.end;

      var timeslices = this.timeslices;
      var startIndex = Number.isFinite(start) ? this._indexOf(start, LEFT) : 0;
      var endIndex = Number.isFinite(end) ? this._indexOf(end, RIGHT) : timeslices.length;
      return timeslices.slice(startIndex, endIndex);
    }
    /**
     * Deprecated for perf reasons
     * Gets loaded stream slices within the current buffer
     */

  }, {
    key: "getStreams",
    value: function getStreams() {
      var streams = this.streams;
      var result = {};

      for (var streamName in streams) {
        result[streamName] = streams[streamName].filter(function (value) {
          return value !== undefined;
        });
      }

      return result;
    }
    /**
     * Gets loaded video frames within the current buffer
     */

  }, {
    key: "getVideos",
    value: function getVideos() {
      var videos = this.videos;
      var result = {};

      for (var streamName in videos) {
        result[streamName] = videos[streamName].filter(function (value) {
          return value !== undefined;
        });
      }

      return result;
    }
    /**
     * Get vehicle poses within the current buffer
     */

  }, {
    key: "getVehiclePoses",
    value: function getVehiclePoses() {
      return this.timeslices.map(function (t) {
        return t.vehiclePose;
      }).filter(Boolean);
    }
    /**
     * Add a new timeslice object into the timeline
     * @params {object} timeslice - timeslice object from XVIZ stream
     */

  }, {
    key: "insert",
    value: function insert(timeslice) {
      var timestamp = timeslice.timestamp;

      if (!this.isInBufferRange(timestamp)) {
        return false;
      } // backwards compatibility - normalize time slice


      timeslice.streams = timeslice.streams || {};
      timeslice.videos = timeslice.videos || {};
      var timeslices = this.timeslices,
          streams = this.streams,
          videos = this.videos;

      for (var streamName in timeslice.streams) {
        if (!streams[streamName]) {
          streams[streamName] = new Array(timeslices.length);
        }
      }

      for (var _streamName in timeslice.videos) {
        if (!videos[_streamName]) {
          videos[_streamName] = new Array(timeslices.length);
        }
      }

      var insertPosition = this._indexOf(timestamp, LEFT);

      var timesliceAtInsertPosition = timeslices[insertPosition];

      if (timesliceAtInsertPosition && timesliceAtInsertPosition.timestamp === timestamp) {
        // Same timestamp, needs a merge
        this._mergeTimesliceAt(insertPosition, timeslice);
      } else {
        this._insertTimesliceAt(insertPosition, timeslice);
      }

      this.lastUpdate++;
      return true;
    }
    /**
     * Set the current timestamp
     * May drop timeslices that are not in range
     * @params {number} timestamp - timestamp of the playhead
     */

  }, {
    key: "setCurrentTime",
    value: function setCurrentTime(timestamp) {
      if (this.bufferType === OFFSET) {
        var _this$options = this.options,
            startOffset = _this$options.startOffset,
            endOffset = _this$options.endOffset;
        this.bufferStart = timestamp + startOffset;
        this.bufferEnd = timestamp + endOffset;

        this._pruneBuffer();
      }
    }
    /**
     * Override Object.prototype.valueOf
     * This is used to trigger a selector update without creating a new XVIZStreamBuffer instance
     */

  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.lastUpdate;
    }
    /**
     * Provide interface for video-synchronizer to test for valid gps-based time range data.
     *
     * @params {number} fromTime is the gps time start of data
     * @params {number} toTime is the gps time end of data
     * @returns {bool} If we have no data, always return true, else true is returned
     *                 if the time range is satisfied
     */

  }, {
    key: "hasBuffer",
    value: function hasBuffer(fromTime, toTime) {
      if (!this.timeslices.length) {
        return true;
      }

      var _this$getLoadedTimeRa = this.getLoadedTimeRange(),
          start = _this$getLoadedTimeRa.start,
          end = _this$getLoadedTimeRa.end;

      return fromTime >= start && toTime <= end;
    }
    /**
     * Check if a timestamp is inside the desired buffer range
     * @params {number} timestamp
     * @returns {bool}
     */

  }, {
    key: "isInBufferRange",
    value: function isInBufferRange(timestamp) {
      var bufferStart = this.bufferStart,
          bufferEnd = this.bufferEnd,
          bufferType = this.bufferType;

      if (bufferType !== UNLIMITED && Number.isFinite(bufferStart)) {
        return timestamp >= bufferStart && timestamp <= bufferEnd;
      }

      return true;
    }
    /* eslint-disable complexity, no-unused-expressions */

  }, {
    key: "_pruneBuffer",
    value: function _pruneBuffer() {
      var timeslices = this.timeslices,
          streams = this.streams,
          videos = this.videos;

      if (timeslices.length) {
        var startIndex = this._indexOf(this.bufferStart, LEFT);

        var endIndex = this._indexOf(this.bufferEnd, RIGHT);

        XVIZObject.prune(this.bufferStart, this.bufferEnd);
        var trimStart = startIndex > 0;
        var trimEnd = endIndex < timeslices.length;

        if (trimStart || trimEnd) {
          // Drop frames that are outside of the buffer
          trimEnd && timeslices.splice(endIndex);
          trimStart && timeslices.splice(0, startIndex);

          for (var streamName in streams) {
            var stream = streams[streamName];
            trimEnd && stream.splice(endIndex);
            trimStart && stream.splice(0, startIndex);
          }

          for (var _streamName2 in videos) {
            var _stream = videos[_streamName2];
            trimEnd && _stream.splice(endIndex);
            trimStart && _stream.splice(0, startIndex);
          }

          this.lastUpdate++;
        }
      }
    }
    /* eslint-enable complexity, no-unused-expressions */

  }, {
    key: "_mergeTimesliceAt",
    value: function _mergeTimesliceAt(index, timeslice) {
      var timeslices = this.timeslices,
          streams = this.streams,
          videos = this.videos;
      var timesliceAtInsertPosition = timeslices[index];
      Object.assign(timesliceAtInsertPosition, timeslice, {
        streams: Object.assign(timesliceAtInsertPosition.streams, timeslice.streams),
        videos: Object.assign(timesliceAtInsertPosition.videos, timeslice.videos)
      });

      for (var streamName in timeslice.streams) {
        streams[streamName][index] = timeslice.streams[streamName];
      }

      for (var _streamName3 in timeslice.videos) {
        videos[_streamName3][index] = timeslice.videos[_streamName3];
      }
    }
  }, {
    key: "_insertTimesliceAt",
    value: function _insertTimesliceAt(index, timeslice) {
      var timeslices = this.timeslices,
          streams = this.streams,
          videos = this.videos;
      timeslices.splice(index, 0, timeslice);

      for (var streamName in streams) {
        streams[streamName].splice(index, 0, timeslice.streams[streamName]);
      }

      for (var _streamName4 in videos) {
        videos[_streamName4].splice(index, 0, timeslice.videos[_streamName4]);
      }
    }
    /**
     * Return insert position for timeslice data given a timestamp
     * @params {number} timestamp
     * @params {number} insertPosition - insert to the left or right of the equal element.
     * @returns {number} index of insert position
     */

  }, {
    key: "_indexOf",
    value: function _indexOf(timestamp) {
      var insertPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LEFT;
      var timeslices = this.timeslices;
      return findInsertPos(timeslices, timestamp, insertPosition);
    }
  }, {
    key: "size",
    get: function get() {
      return this.timeslices.length;
    }
  }]);

  return XVIZStreamBuffer;
}();

export { XVIZStreamBuffer as default };
//# sourceMappingURL=xviz-stream-buffer.js.map