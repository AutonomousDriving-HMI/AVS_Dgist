{"version":3,"sources":["../../../src/synchronizers/xviz-stream-buffer.js"],"names":["XVIZObject","assert","findInsertPos","INSERT_POSITION","LEFT","RIGHT","UNLIMITED","OFFSET","FIXED","XVIZStreamBuffer","constructor","startOffset","endOffset","maxLength","Number","isFinite","bufferType","options","bufferStart","bufferEnd","timeslices","streams","videos","lastUpdate","hasBuffer","bind","size","length","updateFixedBuffer","start","end","Math","min","_pruneBuffer","oldStart","oldEnd","getBufferRange","getLoadedTimeRange","len","timestamp","getTimeslices","startIndex","_indexOf","endIndex","slice","getStreams","getVideos","getVehiclePoses","map","t","vehiclePose","filter","Boolean","insert","timeslice","isInBufferRange","insertPosition","timesliceAtInsertPosition","splice","streamName","timeSlice","setCurrentTime","valueOf","fromTime","toTime","prune"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,UAAP,MAAuB,wBAAvB;AACA,OAAOC,MAAP,MAAmB,iBAAnB;AACA,SAAQC,aAAR,EAAuBC,eAAvB,QAA6C,iBAA7C,C,CAEA;;AACA,MAAMC,IAAI,GAAGD,eAAe,CAACC,IAA7B;AACA,MAAMC,KAAK,GAAGF,eAAe,CAACE,KAA9B,C,CAEA;;AACA,MAAMC,SAAS,GAAG,CAAlB;AACA,MAAMC,MAAM,GAAG,CAAf;AACA,MAAMC,KAAK,GAAG,CAAd;AAEA,eAAe,MAAMC,gBAAN,CAAuB;AACpC;;;;;;;;AAQAC,EAAAA,WAAW,GAAgE;AAAA,mFAAJ,EAAI;AAAA,gCAA9DC,WAA8D;AAAA,QAA9DA,WAA8D,iCAAhD,IAAgD;AAAA,8BAA1CC,SAA0C;AAAA,QAA1CA,SAA0C,+BAA9B,IAA8B;AAAA,8BAAxBC,SAAwB;AAAA,QAAxBA,SAAwB,+BAAZ,IAAY;;AACzE,QAAIC,MAAM,CAACC,QAAP,CAAgBJ,WAAhB,KAAgCG,MAAM,CAACC,QAAP,CAAgBH,SAAhB,CAApC,EAAgE;AAC9DX,MAAAA,MAAM,CAACU,WAAW,IAAI,CAAf,IAAoBC,SAAS,IAAI,CAAlC,EAAqC,qBAArC,CAAN;AACA,WAAKI,UAAL,GAAkBT,MAAlB;AACD,KAHD,MAGO;AACL,WAAKS,UAAL,GAAkBV,SAAlB;AACD;;AAED,SAAKW,OAAL,GAAe;AACbN,MAAAA,WADa;AAEbC,MAAAA,SAFa;AAGbC,MAAAA;AAHa,KAAf;AAMA;;AACA,SAAKK,WAAL,GAAmB,IAAnB;AACA,SAAKC,SAAL,GAAiB,IAAjB;AACA;;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA;;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,MAAL,GAAc,EAAd;AACA;;AACA,SAAKC,UAAL,GAAkB,CAAlB;AAEA,SAAKC,SAAL,GAAiB,KAAKA,SAAL,CAAeC,IAAf,CAAoB,IAApB,CAAjB;AACD;AAED;;;;;AAGA,MAAIC,IAAJ,GAAW;AACT,WAAO,KAAKN,UAAL,CAAgBO,MAAvB;AACD;AAED;;;;;;;;AAMAC,EAAAA,iBAAiB,CAACC,KAAD,EAAQC,GAAR,EAAa;AAAA,UAE1BZ,WAF0B,GAKxB,IALwB,CAE1BA,WAF0B;AAAA,UAG1BC,SAH0B,GAKxB,IALwB,CAG1BA,SAH0B;AAAA,UAIhBN,SAJgB,GAKxB,IALwB,CAI1BI,OAJ0B,CAIhBJ,SAJgB;AAM5BZ,IAAAA,MAAM,CAAC4B,KAAK,GAAGC,GAAT,EAAc,+BAAd,CAAN;AACA7B,IAAAA,MAAM,CACJ,KAAKe,UAAL,KAAoBV,SAApB,IAAiC,KAAKU,UAAL,KAAoBR,KADjD,EAEJ,yCAFI,CAAN;AAIA,SAAKQ,UAAL,GAAkBR,KAAlB;;AAEA,QAAI,CAACK,SAAL,EAAgB;AACd;AACA,WAAKK,WAAL,GAAmBW,KAAnB;AACA,WAAKV,SAAL,GAAiBW,GAAjB;AACD,KAJD,MAIO,IACL,CAAChB,MAAM,CAACC,QAAP,CAAgBG,WAAhB,CAAD,IACAW,KAAK,GAAGV,SAAS,GAAGN,SADpB,IAEAgB,KAAK,GAAGX,WAAW,GAAGL,SAHjB,EAIL;AACA;AACA;AACA,WAAKK,WAAL,GAAmBW,KAAnB;AACA,WAAKV,SAAL,GAAiBY,IAAI,CAACC,GAAL,CAASF,GAAT,EAAcD,KAAK,GAAGhB,SAAtB,CAAjB;AACD,KATM,MASA,IAAIgB,KAAK,GAAGX,WAAZ,EAAyB;AAC9B;AACA;AACA,WAAKA,WAAL,GAAmBW,KAAnB;AACA,WAAKV,SAAL,GAAiBY,IAAI,CAACC,GAAL,CAASb,SAAT,EAAoBU,KAAK,GAAGhB,SAA5B,CAAjB;AACD,KALM,MAKA;AACL;AACA;AACA,WAAKK,WAAL,GAAmBa,IAAI,CAACC,GAAL,CAASb,SAAT,EAAoBW,GAAG,GAAGjB,SAA1B,CAAnB;AACA,WAAKM,SAAL,GAAiBY,IAAI,CAACC,GAAL,CAAS,KAAKd,WAAL,GAAmBL,SAA5B,EAAuCiB,GAAvC,CAAjB;AACD;;AACD,SAAKG,YAAL;;AACA,WAAO;AAACJ,MAAAA,KAAK,EAAE,KAAKX,WAAb;AAA0BY,MAAAA,GAAG,EAAE,KAAKX,SAApC;AAA+Ce,MAAAA,QAAQ,EAAEhB,WAAzD;AAAsEiB,MAAAA,MAAM,EAAEhB;AAA9E,KAAP;AACD;AAED;;;;;;AAIAiB,EAAAA,cAAc,GAAG;AACf,QAAI,KAAKpB,UAAL,KAAoBV,SAAxB,EAAmC;AAAA,YAC1BY,WAD0B,GACA,IADA,CAC1BA,WAD0B;AAAA,YACbC,SADa,GACA,IADA,CACbA,SADa;;AAEjC,UAAIL,MAAM,CAACC,QAAP,CAAgBG,WAAhB,CAAJ,EAAkC;AAChC;AACA,eAAO;AAACW,UAAAA,KAAK,EAAEX,WAAR;AAAqBY,UAAAA,GAAG,EAAEX;AAA1B,SAAP;AACD;AACF;;AACD,WAAO;AAACU,MAAAA,KAAK,EAAE,IAAR;AAAcC,MAAAA,GAAG,EAAE;AAAnB,KAAP;AACD;AAED;;;;;;AAIAO,EAAAA,kBAAkB,GAAG;AAAA,UACZjB,UADY,GACE,IADF,CACZA,UADY;AAEnB,UAAMkB,GAAG,GAAGlB,UAAU,CAACO,MAAvB;;AAEA,QAAIW,GAAG,GAAG,CAAV,EAAa;AACX,aAAO;AACLT,QAAAA,KAAK,EAAET,UAAU,CAAC,CAAD,CAAV,CAAcmB,SADhB;AAELT,QAAAA,GAAG,EAAEV,UAAU,CAACkB,GAAG,GAAG,CAAP,CAAV,CAAoBC;AAFpB,OAAP;AAID;;AACD,WAAO,IAAP;AACD;AAED;;;;;;;;AAMAC,EAAAA,aAAa,GAAoB;AAAA,oFAAJ,EAAI;AAAA,QAAlBX,KAAkB,SAAlBA,KAAkB;AAAA,QAAXC,GAAW,SAAXA,GAAW;;AAAA,UACxBV,UADwB,GACV,IADU,CACxBA,UADwB;AAE/B,UAAMqB,UAAU,GAAG3B,MAAM,CAACC,QAAP,CAAgBc,KAAhB,IAAyB,KAAKa,QAAL,CAAcb,KAAd,EAAqBzB,IAArB,CAAzB,GAAsD,CAAzE;AACA,UAAMuC,QAAQ,GAAG7B,MAAM,CAACC,QAAP,CAAgBe,GAAhB,IAAuB,KAAKY,QAAL,CAAcZ,GAAd,EAAmBzB,KAAnB,CAAvB,GAAmDe,UAAU,CAACO,MAA/E;AACA,WAAOP,UAAU,CAACwB,KAAX,CAAiBH,UAAjB,EAA6BE,QAA7B,CAAP;AACD;AAED;;;;;AAGAE,EAAAA,UAAU,GAAG;AACX,6BAAW,KAAKxB,OAAhB;AACD;AAED;;;;;AAGAyB,EAAAA,SAAS,GAAG;AACV,6BAAW,KAAKxB,MAAhB;AACD;AAED;;;;;AAGAyB,EAAAA,eAAe,GAAG;AAChB,WAAO,KAAK3B,UAAL,CAAgB4B,GAAhB,CAAoBC,CAAC,IAAIA,CAAC,CAACC,WAA3B,EAAwCC,MAAxC,CAA+CC,OAA/C,CAAP;AACD;AAED;;;;;;AAIAC,EAAAA,MAAM,CAACC,SAAD,EAAY;AAChB;AACAA,IAAAA,SAAS,CAACjC,OAAV,GAAoBiC,SAAS,CAACjC,OAAV,IAAqB,EAAzC;AAFgB,UAITD,UAJS,GAIK,IAJL,CAITA,UAJS;AAAA,UAKTmB,SALS,GAKIe,SALJ,CAKTf,SALS;;AAOhB,QAAI,CAAC,KAAKgB,eAAL,CAAqBhB,SAArB,CAAL,EAAsC;AACpC,aAAO,KAAP;AACD;;AAED,UAAMiB,cAAc,GAAG,KAAKd,QAAL,CAAcH,SAAd,EAAyBnC,IAAzB,CAAvB;;AACA,UAAMqD,yBAAyB,GAAGrC,UAAU,CAACoC,cAAD,CAA5C;;AAEA,QAAIC,yBAAyB,IAAIA,yBAAyB,CAAClB,SAA1B,KAAwCA,SAAzE,EAAoF;AAClF;AACAnB,MAAAA,UAAU,CAACoC,cAAD,CAAV,qBACKC,yBADL,EAEKH,SAFL;AAGEjC,QAAAA,OAAO,oBACFoC,yBAAyB,CAACpC,OADxB,EAEFiC,SAAS,CAACjC,OAFR,CAHT;AAOEC,QAAAA,MAAM,oBACDmC,yBAAyB,CAACnC,MADzB,EAEDgC,SAAS,CAAChC,MAFT;AAPR;AAYD,KAdD,MAcO;AACLF,MAAAA,UAAU,CAACsC,MAAX,CAAkBF,cAAlB,EAAkC,CAAlC,EAAqCF,SAArC;AACD;;AAED,SAAK,MAAMK,UAAX,IAAyBL,SAAS,CAACjC,OAAnC,EAA4C;AAC1C,WAAKA,OAAL,CAAasC,UAAb,IAA2BvC,UAAU,CAClC4B,GADwB,CACpBY,SAAS,IAAIA,SAAS,CAACvC,OAAV,CAAkBsC,UAAlB,CADO,EAExBR,MAFwB,CAEjBC,OAFiB,CAA3B;AAGD,KApCe,CAsChB;;;AACA,SAAK,MAAMO,UAAX,IAAyBL,SAAS,CAAChC,MAAnC,EAA2C;AACzC,WAAKA,MAAL,CAAYqC,UAAZ,IAA0BvC,UAAU,CACjC4B,GADuB,CACnBY,SAAS,IAAIA,SAAS,CAACtC,MAAV,IAAoBsC,SAAS,CAACtC,MAAV,CAAiBqC,UAAjB,CADd,EAEvBR,MAFuB,CAEhBC,OAFgB,CAA1B;AAGD;;AAED,SAAK7B,UAAL;AACA,WAAO,IAAP;AACD;AAED;;;;;;;AAKAsC,EAAAA,cAAc,CAACtB,SAAD,EAAY;AACxB,QAAI,KAAKvB,UAAL,KAAoBT,MAAxB,EAAgC;AAAA,4BAG1B,IAH0B,CAE5BU,OAF4B;AAAA,YAElBN,WAFkB,iBAElBA,WAFkB;AAAA,YAELC,SAFK,iBAELA,SAFK;AAI9B,WAAKM,WAAL,GAAmBqB,SAAS,GAAG5B,WAA/B;AACA,WAAKQ,SAAL,GAAiBoB,SAAS,GAAG3B,SAA7B;;AACA,WAAKqB,YAAL;AACD;AACF;AAED;;;;;;AAIA6B,EAAAA,OAAO,GAAG;AACR,WAAO,KAAKvC,UAAZ;AACD;AAED;;;;;;;;;;AAQAC,EAAAA,SAAS,CAACuC,QAAD,EAAWC,MAAX,EAAmB;AAC1B,QAAI,CAAC,KAAK5C,UAAL,CAAgBO,MAArB,EAA6B;AAC3B,aAAO,IAAP;AACD;;AAHyB,kCAIL,KAAKU,kBAAL,EAJK;AAAA,UAInBR,KAJmB,yBAInBA,KAJmB;AAAA,UAIZC,GAJY,yBAIZA,GAJY;;AAK1B,WAAOiC,QAAQ,IAAIlC,KAAZ,IAAqBmC,MAAM,IAAIlC,GAAtC;AACD;AAED;;;;;;;AAKAyB,EAAAA,eAAe,CAAChB,SAAD,EAAY;AAAA,UAClBrB,WADkB,GACoB,IADpB,CAClBA,WADkB;AAAA,UACLC,SADK,GACoB,IADpB,CACLA,SADK;AAAA,UACMH,UADN,GACoB,IADpB,CACMA,UADN;;AAEzB,QAAIA,UAAU,KAAKV,SAAf,IAA4BQ,MAAM,CAACC,QAAP,CAAgBG,WAAhB,CAAhC,EAA8D;AAC5D,aAAOqB,SAAS,IAAIrB,WAAb,IAA4BqB,SAAS,IAAIpB,SAAhD;AACD;;AACD,WAAO,IAAP;AACD;;AAEDc,EAAAA,YAAY,GAAG;AAAA,UACNb,UADM,GACQ,IADR,CACNA,UADM;;AAGb,QAAIA,UAAU,CAACO,MAAf,EAAuB;AACrB,YAAMc,UAAU,GAAG,KAAKC,QAAL,CAAc,KAAKxB,WAAnB,EAAgCd,IAAhC,CAAnB;;AACA,YAAMuC,QAAQ,GAAG,KAAKD,QAAL,CAAc,KAAKvB,SAAnB,EAA8Bd,KAA9B,CAAjB;;AAEAL,MAAAA,UAAU,CAACiE,KAAX,CAAiB,KAAK/C,WAAtB,EAAmC,KAAKC,SAAxC;;AAEA,UAAIsB,UAAU,GAAG,CAAb,IAAkBE,QAAQ,GAAGvB,UAAU,CAACO,MAA5C,EAAoD;AAClD;AACAP,QAAAA,UAAU,CAACsC,MAAX,CAAkBf,QAAlB;AACAvB,QAAAA,UAAU,CAACsC,MAAX,CAAkB,CAAlB,EAAqBjB,UAArB;AAEA,aAAKlB,UAAL;AACD;AACF;AACF;AAED;;;;;;;;AAMAmB,EAAAA,QAAQ,CAACH,SAAD,EAAmC;AAAA,QAAvBiB,cAAuB,uEAANpD,IAAM;AAAA,UAClCgB,UADkC,GACpB,IADoB,CAClCA,UADkC;AAEzC,WAAOlB,aAAa,CAACkB,UAAD,EAAamB,SAAb,EAAwBiB,cAAxB,CAApB;AACD;;AAnSmC","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport XVIZObject from '../objects/xviz-object';\nimport assert from '../utils/assert';\nimport {findInsertPos, INSERT_POSITION} from '../utils/search';\n\n// Insert positions\nconst LEFT = INSERT_POSITION.LEFT;\nconst RIGHT = INSERT_POSITION.RIGHT;\n\n// Buffer types\nconst UNLIMITED = 0;\nconst OFFSET = 1;\nconst FIXED = 2;\n\nexport default class XVIZStreamBuffer {\n  /**\n   * constructor\n   * @param {object} options\n   * @param {number} options.startOffset - desired start of buffer to keep in memory\n   *  relative to the current time.\n   * @param {number} options.endOffset - desired end of buffer to keep in memory\n   *  relative to the current time.\n   */\n  constructor({startOffset = null, endOffset = null, maxLength = null} = {}) {\n    if (Number.isFinite(startOffset) && Number.isFinite(endOffset)) {\n      assert(startOffset <= 0 && endOffset >= 0, 'Steam buffer offset');\n      this.bufferType = OFFSET;\n    } else {\n      this.bufferType = UNLIMITED;\n    }\n\n    this.options = {\n      startOffset,\n      endOffset,\n      maxLength\n    };\n\n    /* Desired buffer range, in timestamps */\n    this.bufferStart = null;\n    this.bufferEnd = null;\n    /* Sorted timeslices */\n    this.timeslices = [];\n    /* Sorted stream slices */\n    this.streams = {};\n    this.videos = {};\n    /* Update counter */\n    this.lastUpdate = 0;\n\n    this.hasBuffer = this.hasBuffer.bind(this);\n  }\n\n  /**\n   * @property {number} the count of timeslices in buffer\n   */\n  get size() {\n    return this.timeslices.length;\n  }\n\n  /**\n   * updates the fixed buffer range, capping it to maxLength if set\n   * @param {number} start - desired fixed start time of buffer to keep in memory\n   * @param {number} end - desired fixed end time of buffer to keep in memory\n   * @returns {start: number, end: number, oldStart: number, oldEnd: number} - the old and new buffer ranges\n   */\n  updateFixedBuffer(start, end) {\n    const {\n      bufferStart,\n      bufferEnd,\n      options: {maxLength}\n    } = this;\n    assert(start < end, 'updateFixedBuffer start / end');\n    assert(\n      this.bufferType === UNLIMITED || this.bufferType === FIXED,\n      'updateFixedBuffer multiple buffer types'\n    );\n    this.bufferType = FIXED;\n\n    if (!maxLength) {\n      // If we have no limits on buffer size, just use the new provided values\n      this.bufferStart = start;\n      this.bufferEnd = end;\n    } else if (\n      !Number.isFinite(bufferStart) ||\n      start > bufferEnd + maxLength ||\n      start < bufferStart - maxLength\n    ) {\n      // If we have a limit but this is our first range definition, or this is so far before the existing\n      // buffer that there's no overlap, use the provided start and determine end based on max buffer length\n      this.bufferStart = start;\n      this.bufferEnd = Math.min(end, start + maxLength);\n    } else if (start < bufferStart) {\n      // If this is before the existing buffer but close enough to have overlap, use the provided start\n      // and determine the end based on max buffer length and the existing buffer end\n      this.bufferStart = start;\n      this.bufferEnd = Math.min(bufferEnd, start + maxLength);\n    } else {\n      // Otherwise, we're past the end of the existing buffer and either extend the existing buffer\n      // or start a new buffer based on maxLength\n      this.bufferStart = Math.min(bufferEnd, end - maxLength);\n      this.bufferEnd = Math.min(this.bufferStart + maxLength, end);\n    }\n    this._pruneBuffer();\n    return {start: this.bufferStart, end: this.bufferEnd, oldStart: bufferStart, oldEnd: bufferEnd};\n  }\n\n  /**\n   * Gets the time range that the buffer is accepting data for\n   * @returns {object} - {start | null, end | null} timestamps if any timeslice is loaded\n   */\n  getBufferRange() {\n    if (this.bufferType !== UNLIMITED) {\n      const {bufferStart, bufferEnd} = this;\n      if (Number.isFinite(bufferStart)) {\n        // buffer range should be ignored if setCurrentTime has not been called\n        return {start: bufferStart, end: bufferEnd};\n      }\n    }\n    return {start: null, end: null};\n  }\n\n  /**\n   * Gets the buffered time range\n   * @returns {object | null} - {start, end} timestamps if any timeslice is loaded\n   */\n  getLoadedTimeRange() {\n    const {timeslices} = this;\n    const len = timeslices.length;\n\n    if (len > 0) {\n      return {\n        start: timeslices[0].timestamp,\n        end: timeslices[len - 1].timestamp\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Gets timeslices within a given time range.\n   * @params {number, optional} start - start timestamp (inclusive)\n   * @params {number, optional} end - end timestamp (inclusive)\n   * @returns {array} - loaded timeslices within range\n   */\n  getTimeslices({start, end} = {}) {\n    const {timeslices} = this;\n    const startIndex = Number.isFinite(start) ? this._indexOf(start, LEFT) : 0;\n    const endIndex = Number.isFinite(end) ? this._indexOf(end, RIGHT) : timeslices.length;\n    return timeslices.slice(startIndex, endIndex);\n  }\n\n  /**\n   * Gets loaded stream slices within the current buffer\n   */\n  getStreams() {\n    return {...this.streams};\n  }\n\n  /**\n   * Gets loaded video frames within the current buffer\n   */\n  getVideos() {\n    return {...this.videos};\n  }\n\n  /**\n   * Get vehicle poses within the current buffer\n   */\n  getVehiclePoses() {\n    return this.timeslices.map(t => t.vehiclePose).filter(Boolean);\n  }\n\n  /**\n   * Add a new timeslice object into the timeline\n   * @params {object} timeslice - timeslice object from XVIZ stream\n   */\n  insert(timeslice) {\n    // backwards compatibility - normalize time slice\n    timeslice.streams = timeslice.streams || {};\n\n    const {timeslices} = this;\n    const {timestamp} = timeslice;\n\n    if (!this.isInBufferRange(timestamp)) {\n      return false;\n    }\n\n    const insertPosition = this._indexOf(timestamp, LEFT);\n    const timesliceAtInsertPosition = timeslices[insertPosition];\n\n    if (timesliceAtInsertPosition && timesliceAtInsertPosition.timestamp === timestamp) {\n      // Same timestamp, needs a merge\n      timeslices[insertPosition] = {\n        ...timesliceAtInsertPosition,\n        ...timeslice,\n        streams: {\n          ...timesliceAtInsertPosition.streams,\n          ...timeslice.streams\n        },\n        videos: {\n          ...timesliceAtInsertPosition.videos,\n          ...timeslice.videos\n        }\n      };\n    } else {\n      timeslices.splice(insertPosition, 0, timeslice);\n    }\n\n    for (const streamName in timeslice.streams) {\n      this.streams[streamName] = timeslices\n        .map(timeSlice => timeSlice.streams[streamName])\n        .filter(Boolean);\n    }\n\n    // TODO - remove when updating to v2\n    for (const streamName in timeslice.videos) {\n      this.videos[streamName] = timeslices\n        .map(timeSlice => timeSlice.videos && timeSlice.videos[streamName])\n        .filter(Boolean);\n    }\n\n    this.lastUpdate++;\n    return true;\n  }\n\n  /**\n   * Set the current timestamp\n   * May drop timeslices that are not in range\n   * @params {number} timestamp - timestamp of the playhead\n   */\n  setCurrentTime(timestamp) {\n    if (this.bufferType === OFFSET) {\n      const {\n        options: {startOffset, endOffset}\n      } = this;\n      this.bufferStart = timestamp + startOffset;\n      this.bufferEnd = timestamp + endOffset;\n      this._pruneBuffer();\n    }\n  }\n\n  /**\n   * Override Object.prototype.valueOf\n   * This is used to trigger a selector update without creating a new XVIZStreamBuffer instance\n   */\n  valueOf() {\n    return this.lastUpdate;\n  }\n\n  /**\n   * Provide interface for video-synchronizer to test for valid gps-based time range data.\n   *\n   * @params {number} fromTime is the gps time start of data\n   * @params {number} toTime is the gps time end of data\n   * @returns {bool} If we have no data, always return true, else true is returned\n   *                 if the time range is satisfied\n   */\n  hasBuffer(fromTime, toTime) {\n    if (!this.timeslices.length) {\n      return true;\n    }\n    const {start, end} = this.getLoadedTimeRange();\n    return fromTime >= start && toTime <= end;\n  }\n\n  /**\n   * Check if a timestamp is inside the desired buffer range\n   * @params {number} timestamp\n   * @returns {bool}\n   */\n  isInBufferRange(timestamp) {\n    const {bufferStart, bufferEnd, bufferType} = this;\n    if (bufferType !== UNLIMITED && Number.isFinite(bufferStart)) {\n      return timestamp >= bufferStart && timestamp <= bufferEnd;\n    }\n    return true;\n  }\n\n  _pruneBuffer() {\n    const {timeslices} = this;\n\n    if (timeslices.length) {\n      const startIndex = this._indexOf(this.bufferStart, LEFT);\n      const endIndex = this._indexOf(this.bufferEnd, RIGHT);\n\n      XVIZObject.prune(this.bufferStart, this.bufferEnd);\n\n      if (startIndex > 0 || endIndex < timeslices.length) {\n        // Drop frames that are outside of the buffer\n        timeslices.splice(endIndex);\n        timeslices.splice(0, startIndex);\n\n        this.lastUpdate++;\n      }\n    }\n  }\n\n  /**\n   * Return insert position for timeslice data given a timestamp\n   * @params {number} timestamp\n   * @params {number} insertPosition - insert to the left or right of the equal element.\n   * @returns {number} index of insert position\n   */\n  _indexOf(timestamp, insertPosition = LEFT) {\n    const {timeslices} = this;\n    return findInsertPos(timeslices, timestamp, insertPosition);\n  }\n}\n"],"file":"xviz-stream-buffer.js"}