{"version":3,"sources":["../../../../src/layers/mesh-layer/mesh-layer-vertex.glsl.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\n#define SHADER_NAME mesh-layer-vs\n\n// Scale the model\nuniform float sizeScale;\n\n// Primitive attributes\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec2 texCoords;\n\n// Instance attributes\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xy;\nattribute vec3 instanceRotations;\nattribute vec3 instanceSizes;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\n// Outputs to fragment shader\nvarying vec2 vTexCoord;\nvarying vec4 vColor;\nvarying float vLightWeight;\n\n// yaw(z) pitch(y) roll(x)\nmat3 getRotationMatrix(vec3 rotation) {\n  float sr = sin(rotation.x);\n  float sp = sin(rotation.y);\n  float sw = sin(rotation.z);\n\n  float cr = cos(rotation.x);\n  float cp = cos(rotation.y);\n  float cw = cos(rotation.z);\n\n  return mat3(\n    cw * cp,                  // 0,0\n    sw * cp,                  // 1,0\n    -sp,                      // 2,0\n    -sw * cr + cw * sp * sr,  // 0,1\n    cw * cr + sw * sp * sr,   // 1,1\n    cp * sr,                  // 2,1\n    sw * sr + cw * sp * cr,   // 0,2\n    -cw * sr + sw * sp * cr,  // 1,2\n    cp * cr                   // 2,2\n  );\n}\n\nvoid main(void) {\n  mat3 rotationMatrix = getRotationMatrix(instanceRotations);\n\n  vec3 pos = positions * instanceSizes * sizeScale;\n  pos = rotationMatrix * pos;\n  pos = (project_uModelMatrix * vec4(pos, 0.0)).xyz;\n  pos = project_scale(pos);\n\n  vec4 worldPosition;\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xy, pos, worldPosition);\n\n  vec3 normal = rotationMatrix * normals;\n  normal = project_normal(normal);\n\n  picking_setPickingColor(instancePickingColors);\n\n  vTexCoord = texCoords;\n  vColor = instanceColors / 255.;\n  vLightWeight = lighting_getLightWeight(worldPosition.xyz, normal);\n}\n`;\n"],"file":"mesh-layer-vertex.glsl.js"}