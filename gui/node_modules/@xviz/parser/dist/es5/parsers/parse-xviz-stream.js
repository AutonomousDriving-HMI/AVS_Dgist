"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseXVIZStream = parseXVIZStream;
exports.parseStreamPrimitive = parseStreamPrimitive;
exports.parseStreamFutures = parseStreamFutures;
exports.parseStreamFuturesV1 = parseStreamFuturesV1;
exports.parseStreamFuturesV2 = parseStreamFuturesV2;
exports.parseStreamVariable = parseStreamVariable;
exports.parseStreamVariableV1 = parseStreamVariableV1;
exports.parseStreamVariableV2 = parseStreamVariableV2;
exports.parseStreamTimeSeries = parseStreamTimeSeries;
exports.parseStreamUIPrimitives = parseStreamUIPrimitives;

var _xvizConfig = require("../config/xviz-config");

var _parseXvizPrimitive = require("./parse-xviz-primitive");

var _xvizObject = _interopRequireDefault(require("../objects/xviz-object"));

var _globals = require("../utils/globals");

var _log = _interopRequireDefault(require("../utils/log"));

var _xvizV2Common = require("./xviz-v2-common");

var _xvizPrimitivesV = _interopRequireDefault(require("./xviz-primitives-v1"));

var _xvizPrimitivesV2 = _interopRequireDefault(require("./xviz-primitives-v2"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2019 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
function createPrimitiveMap() {
  var result = {};

  for (var key in _parseXvizPrimitive.PRIMITIVE_CAT) {
    result[_parseXvizPrimitive.PRIMITIVE_CAT[key]] = [];
  }

  return result;
}
/* eslint-disable max-depth, max-statements, complexity, camelcase */
// Handle stream-sliced data, via the ETL flow.


function parseXVIZStream(data, convertPrimitive) {
  // data is an array of objects
  // Each object is [{primitives, variables, timestamp},...]
  // Each object represents a timestamp and array of objects
  // V1 has a no-data entry that results in setting all top-level types to an
  // empty array. See the test cases.
  //
  // Usually only one of these fields is valid and thus only one is normally
  // iterated below.
  var _data$ = data[0],
      primitives = _data$.primitives,
      ui_primitives = _data$.ui_primitives,
      variables = _data$.variables,
      futures = _data$.futures; // At this point, we either have one or the other.
  // TODO(twojtasz): BUG: there is an assumption that
  // streamNames will be unique.  Need to put in a detection if
  // that is violated.

  if (primitives) {
    var streamName = Object.keys(primitives)[0];
    return data.map(function (datum) {
      return parseStreamPrimitive(datum.primitives[streamName], streamName, datum.timestamp, convertPrimitive);
    });
  } else if (variables) {
    var _streamName = Object.keys(variables)[0];
    return data.map(function (datum) {
      return parseStreamVariable(datum.variables[_streamName], _streamName, datum.timestamp);
    });
  } else if (futures) {
    var _streamName2 = Object.keys(futures)[0];
    return data.map(function (datum) {
      return parseStreamFutures(datum.futures[_streamName2], _streamName2, datum.timestamp, convertPrimitive);
    });
  } else if (ui_primitives) {
    var _streamName3 = Object.keys(ui_primitives)[0];
    return data.map(function (datum) {
      return parseStreamUIPrimitives(datum.ui_primitives[_streamName3], _streamName3, datum.timestamp);
    });
  }

  return {};
}
/* Processes an individual primitive time sample and converts the
 * data to UI elements.
 */


function parseStreamPrimitive(primitives, streamName, time, convertPrimitive) {
  var _getXVIZConfig = (0, _xvizConfig.getXVIZConfig)(),
      OBJECT_STREAM = _getXVIZConfig.OBJECT_STREAM,
      preProcessPrimitive = _getXVIZConfig.preProcessPrimitive;

  var PRIMITIVE_SETTINGS = (0, _xvizConfig.getXVIZConfig)().currentMajorVersion === 1 ? _xvizPrimitivesV.default : _xvizPrimitivesV2.default;
  var primitiveData = (0, _xvizV2Common.getPrimitiveData)(primitives);

  if (!primitiveData || !Array.isArray(primitiveData.primitives)) {
    return {};
  }

  var primType = primitiveData.type,
      objects = primitiveData.primitives;
  var primitiveMap = createPrimitiveMap();
  var category = null; // Primitives are an array of XVIZ objects

  for (var objectIndex = 0; objectIndex < objects.length; objectIndex++) {
    var object = objects[objectIndex]; // array of primitives

    if (object && Array.isArray(object)) {
      category = _parseXvizPrimitive.PRIMITIVE_CAT.LOOKAHEAD;
      primitiveMap[category].push([]);

      for (var j = 0; j < object.length; j++) {
        // Apply custom XVIZ pre processing to this primitive
        preProcessPrimitive({
          primitive: object[j],
          streamName: streamName,
          time: time
        }); // process each primitive

        var primitive = (0, _parseXvizPrimitive.normalizeXVIZPrimitive)(PRIMITIVE_SETTINGS, object[j], objectIndex, streamName, primType, time, convertPrimitive);

        if (primitive) {
          primitiveMap[category][objectIndex].push(primitive);
        }
      }
    } else {
      // single primitive
      // Apply custom XVIZ postprocessing to this primitive
      preProcessPrimitive({
        primitive: object,
        streamName: streamName,
        time: time
      }); // normalize primitive

      var _primitive = (0, _parseXvizPrimitive.normalizeXVIZPrimitive)(PRIMITIVE_SETTINGS, object, objectIndex, streamName, primType, time, convertPrimitive); // Allow for v1 inline type to override primitive type


      category = PRIMITIVE_SETTINGS[object.type || primType].category;

      if (_primitive) {
        primitiveMap[category].push(_primitive);

        if (_globals.isMainThread && ( // OBJECT_STREAM is deprecated, only keeping for backward compatibility
        streamName === OBJECT_STREAM || !OBJECT_STREAM && _primitive.id && category === 'features')) {
          _xvizObject.default.observe(_primitive.id, time);
        }
      }
    }
  }

  primitiveMap.pointCloud = joinObjectPointCloudsToTypedArrays(primitiveMap.pointCloud);
  primitiveMap.time = time;
  return primitiveMap;
}
/* Processes the futures and converts the
 * data to UI elements.
 */


function parseStreamFutures(objects, streamName, time, convertPrimitive) {
  var _getXVIZConfig2 = (0, _xvizConfig.getXVIZConfig)(),
      currentMajorVersion = _getXVIZConfig2.currentMajorVersion;

  return currentMajorVersion === 1 ? parseStreamFuturesV1(objects, streamName, time, convertPrimitive) : parseStreamFuturesV2(objects, streamName, time, convertPrimitive);
}

function parseStreamFuturesV1(objects, streamName, time, convertPrimitive) {
  var futures = []; // objects = array of objects
  // [{timestamp, primitives[]}, ...]
  // Futures are an array of array of primitives and
  // the objectIndex is used to find the timestamp associated
  // with the set of primitives.

  objects.forEach(function (object, objectIndex) {
    var primitives = object.primitives;
    var future = primitives.map(function (primitive) {
      return (0, _parseXvizPrimitive.normalizeXVIZPrimitive)(_xvizPrimitivesV.default, primitive, objectIndex, streamName, primitive.type, time, convertPrimitive);
    }).filter(Boolean);
    futures.push(future);
  });
  return {
    time: time,
    lookAheads: futures
  };
}

function parseStreamFuturesV2(objects, streamName, time, convertPrimitive) {
  var futures = []; // objects = {
  //   timestamps: [1, 2, 3],
  //   primitives: [
  //    { <type>: [ <objects for ts[1]> ] },
  //    { <type>: [ <objects for ts[2]> ] },
  //    { <type>: [ <objects for ts[3]> ] }
  //   ]
  // }

  var timestamps = objects.timestamps;
  objects.primitives.forEach(function (future_set, futureIndex) {
    // Get the underlying primitive array
    var data = (0, _xvizV2Common.getPrimitiveData)(future_set);
    var future = data.primitives.map(function (primitive) {
      var normalizedPrimitive = (0, _parseXvizPrimitive.normalizeXVIZPrimitive)(_xvizPrimitivesV2.default, primitive, futureIndex, streamName, data.type, time, convertPrimitive);
      normalizedPrimitive.timestamp = timestamps[futureIndex];
      return normalizedPrimitive;
    }).filter(Boolean);
    futures.push(future);
  });
  return {
    time: time,
    lookAheads: futures
  };
}
/* Processes an individual variable time sample and converts the
 * data to UI elements.
 */


function parseStreamVariable(objects, streamName, time) {
  var _getXVIZConfig3 = (0, _xvizConfig.getXVIZConfig)(),
      currentMajorVersion = _getXVIZConfig3.currentMajorVersion;

  return currentMajorVersion === 1 ? parseStreamVariableV1(objects, streamName, time) : parseStreamVariableV2(objects, streamName, time);
}

function parseStreamVariableV1(objects, streamName, time) {
  if (Array.isArray(objects)) {
    return {
      time: time
    };
  }

  var variable;
  var timestamps = objects.timestamps,
      values = objects.values;

  if (values.length === 1) {
    variable = values[0];
  } else if (timestamps) {
    variable = values.map(function (v, i) {
      return [timestamps[i], v];
    });
  } else {
    variable = values;
  }

  var entry = {
    time: time,
    variable: variable
  };
  return entry;
}

function parseStreamVariableV2(objects, streamName, time) {
  if (Array.isArray(objects)) {
    return {
      time: time
    };
  }

  var variables = objects.variables;

  if (!variables || !Array.isArray(variables)) {
    return {};
  }

  var result = {
    time: time
  };
  result.variable = variables.map(function (entry) {
    var base = entry.base,
        values = entry.values;
    var valueData = getVariableData(values);

    if (!valueData || !valueData.values) {
      return null;
    }

    var datum = {
      values: valueData.values
    };

    if (base && base.object_id) {
      datum.id = base.object_id;
    }

    return datum;
  }).filter(Boolean);
  return result;
}
/* Processes a time_series sample and converts the
 * data to UI elements.
 */


function parseStreamTimeSeries(seriesArray, streamBlackList) {
  var _getXVIZConfig4 = (0, _xvizConfig.getXVIZConfig)(),
      currentMajorVersion = _getXVIZConfig4.currentMajorVersion;

  if (currentMajorVersion === 2) {
    return parseStreamTimeSeriesV2(seriesArray, streamBlackList);
  }

  _log.default.error("Invalid time_series data in XVIZ version ".concat(currentMajorVersion))();

  return null;
}

var ValueTypes = ['doubles', 'int32s', 'bools', 'strings'];

function getVariableData(valuesObject) {
  // Primitives have the type as the first key
  var keys = Object.keys(valuesObject);

  for (var _i = 0; _i < keys.length; _i++) {
    var type = keys[_i];

    if (ValueTypes.includes(type)) {
      return {
        type: type,
        values: valuesObject[type]
      };
    }
  } // TODO(twojtasz): a more informative error path that doesn't abort processing


  return {};
}

function parseStreamTimeSeriesV2(seriesArray, streamBlackList) {
  if (!Array.isArray(seriesArray)) {
    return {};
  }

  var timeSeriesStreams = {};
  seriesArray.forEach(function (timeSeriesEntry) {
    var timestamp = timeSeriesEntry.timestamp,
        streams = timeSeriesEntry.streams,
        values = timeSeriesEntry.values,
        object_id = timeSeriesEntry.object_id;
    var valueData = getVariableData(values);

    if (!valueData || valueData.values.length !== streams.length) {
      return null;
    }

    valueData.values.forEach(function (variable, entryIndex) {
      var streamName = streams[entryIndex];

      if (!streamBlackList.has(streamName)) {
        var entry = {
          time: timestamp,
          variable: variable
        };

        if (object_id) {
          entry.id = object_id;
        }

        var tsStream = timeSeriesStreams[streamName];

        if (tsStream) {
          // a duplicate entry is seen, leave the first entry.
          _log.default.warn("Unexpected time_series duplicate: ".concat(streamName))();
        } else {
          timeSeriesStreams[streamName] = entry;
        }
      }
    }); // eslint consistent-return warning
    // This for loop we do not need to return any value

    return timeSeriesStreams;
  });
  return timeSeriesStreams;
}

function getVertexCount(vertices) {
  return Number.isFinite(vertices[0]) ? vertices.length / 3 : vertices.length;
}

function getColorStride(colors, vertexCount) {
  if (colors) {
    if (colors.length / 4 === vertexCount) {
      return 4;
    }

    if (colors.length / 3 === vertexCount) {
      return 3;
    }

    var stride;

    if (Array.isArray(colors[0])) {
      stride = colors[0].length;
    } else {
      stride = colors.length;
    }

    if (stride === 3 || stride === 4) {
      return stride;
    }

    _log.default.error('Unknown point color format');
  }

  return 0;
}

var DEFAULT_COLOR = [0, 0, 0, 255]; // Joins a set of point clouds extracted from objects into a single point cloud
// generates typed arrays that can be displayed efficiently by deck.gl

function joinObjectPointCloudsToTypedArrays(objects) {
  if (objects.length === 0) {
    return null;
  }

  var numInstances = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = objects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var object = _step.value;
      numInstances += getVertexCount(object.vertices);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var vertexColorStride = null;
  var positions = new Float32Array(numInstances * 3);
  var colors = new Uint8ClampedArray(numInstances * 4); // Store object ids to enable recoloring.
  // NOTE: Not a vertex attribute, ids are just efficiently stored as as 32 bit integers...

  var ids = new Uint32Array(numInstances);
  var i = 0;
  objects.forEach(function (object) {
    var vertexPositions = object.vertices; // object.color is V1 and should be removed when deprecated

    var vertexColors = object.colors;
    var vertexCount = getVertexCount(vertexPositions);

    if (vertexCount === 0) {
      return;
    } // Setup for per-point color


    var colorStride = getColorStride(vertexColors || object.color, vertexCount);

    if (vertexColorStride !== null && vertexColorStride !== colorStride) {
      _log.default.error('Inconsistent point color format');
    }

    vertexColorStride = colorStride;
    var isColorFlattenedArray = vertexColors && vertexColors.length === vertexCount * vertexColorStride;

    if (isColorFlattenedArray) {
      colors.set(vertexColors, i * vertexColorStride);
    }

    var isPositionFlattenedArray = vertexPositions.length === vertexCount * 3;

    if (isPositionFlattenedArray) {
      positions.set(vertexPositions, i * 3);
    }

    var color = object.color || DEFAULT_COLOR;

    for (var j = 0; j < vertexCount; j++, i++) {
      ids[i] = object.id;

      if (!isPositionFlattenedArray) {
        var vertex = vertexPositions[j];
        positions[i * 3 + 0] = vertex[0];
        positions[i * 3 + 1] = vertex[1];
        positions[i * 3 + 2] = vertex[2];
      }

      if (!isColorFlattenedArray && vertexColorStride) {
        if (vertexColors) {
          color = vertexColors[j];
        }

        colors[i * vertexColorStride + 0] = color[0];
        colors[i * vertexColorStride + 1] = color[1];
        colors[i * vertexColorStride + 2] = color[2];

        if (vertexColorStride === 4) {
          colors[i * vertexColorStride + 3] = color[3] || 255;
        }
      }
    }
  });
  return {
    type: objects[0].type,
    numInstances: numInstances,
    positions: positions,
    colors: vertexColorStride ? colors.subarray(0, vertexColorStride * numInstances) : null,
    ids: ids
  };
}

function parseStreamUIPrimitives(components, streamName, time) {
  return Object.assign({
    time: time
  }, components);
}
//# sourceMappingURL=parse-xviz-stream.js.map