function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

import { getBytesFromComponentType, getSizeFromAccessorType } from '../utils/gltf-type-utils';
import GLBParser from '../glb/glb-parser';
var GL_SAMPLER = {
  TEXTURE_MAG_FILTER: 0x2800,
  TEXTURE_MIN_FILTER: 0x2801,
  TEXTURE_WRAP_S: 0x2802,
  TEXTURE_WRAP_T: 0x2803
};
var SAMPLER_PARAMETER_GLTF_TO_GL = {
  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
  wrapT: GL_SAMPLER.TEXTURE_WRAP_T
};
var DEFAULT_OPTIONS = {
  createImages: false
};

var GLTFParser =
/*#__PURE__*/
function () {
  function GLTFParser() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, GLTFParser);

    // TODO - move parsing to parse
    this.log = console; // eslint-disable-line

    this.out = {};
    this.options = Object.assign({}, DEFAULT_OPTIONS, options); // Soft dependency on Draco, needs to be imported and supplied by app

    this.DracoDecoder = this.options.DracoDecoder || null;
  }

  _createClass(GLTFParser, [{
    key: "parse",
    value: function parse(gltf) {
      var optionsParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = Object.assign({}, this.options, optionsParam); // GLTF can be JSON or binary (GLB)

      if (gltf instanceof ArrayBuffer) {
        this.glbParser = new GLBParser();
        this.gltf = this.glbParser.parse(gltf).json;
        this.json = this.gltf;
      } else {
        this.glbParser = null;
        this.gltf = gltf;
        this.json = gltf;
      }

      this._loadLinkedAssets(options); // TODO - not implemented
      // this._postProcessGLTF(options); TODO - remove done differently now


      this._resolveToTree(options);

      return this.gltf;
    } // Accessors

  }, {
    key: "getApplicationData",
    value: function getApplicationData(key) {
      // TODO - Data is already unpacked by GLBParser
      var data = this.json[key];
      return data;
    }
  }, {
    key: "getExtraData",
    value: function getExtraData(key) {
      // TODO - Data is already unpacked by GLBParser
      var extras = this.json.extras || {};
      return extras[key];
    }
  }, {
    key: "getExtension",
    value: function getExtension(extensionName) {
      // TODO - Data is already unpacked by GLBParser
      return this.json.extensions[extensionName];
    }
  }, {
    key: "getRequiredExtensions",
    value: function getRequiredExtensions() {
      return this.json.extensionsRequired;
    }
  }, {
    key: "getUsedExtensions",
    value: function getUsedExtensions() {
      return this.json.extensionsUsed;
    } // DATA UNPACKING
    // Unpacks all the primitives in a mesh

  }, {
    key: "unpackMesh",
    value: function unpackMesh(mesh) {
      return mesh.primitives.map(this.unpackPrimitive.bind(this));
    } // Unpacks one mesh primitive

  }, {
    key: "unpackPrimitive",
    value: function unpackPrimitive(primitive) {
      var compressedMesh = primitive.extensions && primitive.extensions.UBER_draco_mesh_compression;
      var compressedPointCloud = primitive.extensions && primitive.extensions.UBER_draco_point_cloud_compression;
      var unpackedPrimitive = {
        mode: primitive.mode,
        material: primitive.material
      };

      if (compressedMesh) {
        var dracoDecoder = new this.DracoDecoder();
        var decodedData = dracoDecoder.decodeMesh(compressedMesh);
        dracoDecoder.destroy();
        Object.assign(unpackedPrimitive, {
          indices: decodedData.indices,
          attributes: decodedData.attributes
        });
      } else if (compressedPointCloud) {
        var _dracoDecoder = new this.DracoDecoder();

        var _decodedData = _dracoDecoder.decodePointCloud(compressedPointCloud);

        _dracoDecoder.destroy();

        Object.assign(unpackedPrimitive, {
          mode: 0,
          attributes: _decodedData.attributes
        });
      } else {// No compression - just a glTF mesh primitive
        // TODO - Resolve all accessors
      }
    } // PRIVATE

  }, {
    key: "getScene",
    value: function getScene(index) {
      return this._get('scenes', index);
    }
  }, {
    key: "getNode",
    value: function getNode(index) {
      return this._get('nodes', index);
    }
  }, {
    key: "getSkin",
    value: function getSkin(index) {
      return this._get('skins', index);
    }
  }, {
    key: "getMesh",
    value: function getMesh(index) {
      return this._get('meshes', index);
    }
  }, {
    key: "getDecompressedMesh",
    value: function getDecompressedMesh(index) {
      if (!this.DracoDecoder) {
        throw new Error('DracoDecoder not available');
      }

      var mesh = this._get('meshes', index);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = mesh.primitives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var primitive = _step.value;
          // TODO: DracoMesh extension
          var extensions = primitive.extensions;

          if ('UBER_draco_point_cloud_compression' in extensions) {
            this._decompressUberDracoPointCloud(primitive, extensions);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return mesh;
    }
  }, {
    key: "getMaterial",
    value: function getMaterial(index) {
      return this._get('materials', index);
    }
  }, {
    key: "getAccessor",
    value: function getAccessor(index) {
      return this._get('accessors', index);
    }
  }, {
    key: "getCamera",
    value: function getCamera(index) {
      return null; // TODO: fix this
    }
  }, {
    key: "getTexture",
    value: function getTexture(index) {
      return this._get('textures', index);
    }
  }, {
    key: "getSampler",
    value: function getSampler(index) {
      return this._get('samplers', index);
    }
  }, {
    key: "getImage",
    value: function getImage(index) {
      return this._get('images', index);
    }
  }, {
    key: "getBufferView",
    value: function getBufferView(index) {
      return this._get('bufferViews', index);
    }
  }, {
    key: "getBuffer",
    value: function getBuffer(index) {
      return this._get('buffers', index);
    }
  }, {
    key: "_get",
    value: function _get(array, index) {
      var object = this.gltf[array] && this.gltf[array][index];

      if (!object) {
        console.warn("glTF file error: Could not find ".concat(array, "[").concat(index, "]")); // eslint-disable-line
      }

      return object;
    } // PARSING HELPERS
    // Start loading linked assets

  }, {
    key: "_loadLinkedAssets",
    value: function _loadLinkedAssets(options) {// TODO: Not implemented
      // TODO: Return a promise?
    }
  }, {
    key: "_postProcessGLTF",
    value: function _postProcessGLTF() {
      var _this = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // Create all images (if requested)
      this.out.images = (this.gltf.images || []).map(function (image) {
        return _this.parseImage(image, options);
      }).filter(Boolean); // Normalize all scenes

      this.out.scenes = (this.gltf.scenes || []).map(function (scene) {
        return _this.parseScene(scene, options);
      }).filter(Boolean);

      if (this.gltf.scene !== undefined) {
        this.out.scene = this.gltf.scenes[this.gltf.scene];
      }

      return this;
    } // Convert indexed glTF structure into tree structure
    // PREPARATION STEP: CROSS-LINK INDEX RESOLUTION, ENUM LOOKUP, CONVENIENCE CALCULATIONS

    /* eslint-disable complexity */

  }, {
    key: "_resolveToTree",
    value: function _resolveToTree() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var gltf = this.gltf;
      (gltf.bufferViews || []).forEach(function (bufView, i) {
        return _this2._resolveBufferView(bufView, i);
      });
      (gltf.images || []).forEach(function (image, i) {
        return _this2._resolveImage(image, i, options);
      });
      (gltf.samplers || []).forEach(function (sampler, i) {
        return _this2._resolveSampler(sampler, i);
      });
      (gltf.textures || []).forEach(function (texture, i) {
        return _this2._resolveTexture(texture, i);
      });
      (gltf.accessors || []).forEach(function (accessor, i) {
        return _this2._resolveAccessor(accessor, i);
      });
      (gltf.materials || []).forEach(function (material, i) {
        return _this2._resolveMaterial(material, i);
      });
      (gltf.meshes || []).forEach(function (mesh, i) {
        return _this2._resolveMesh(mesh, i);
      });
      (gltf.nodes || []).forEach(function (node, i) {
        return _this2._resolveNode(node, i);
      });
      (gltf.skins || []).forEach(function (skin, i) {
        return _this2._resolveSkin(skin, i);
      });
      (gltf.scenes || []).forEach(function (scene, i) {
        return _this2._resolveScene(scene, i);
      });

      if (gltf.scene !== undefined) {
        gltf.scene = gltf.scenes[this.gltf.scene];
      }

      return gltf;
    }
    /* eslint-enable complexity */

  }, {
    key: "_resolveScene",
    value: function _resolveScene(scene, index) {
      var _this3 = this;

      scene.id = "scene-".concat(index);
      scene.nodes = (scene.nodes || []).map(function (node) {
        return _this3.getNode(node);
      });
    }
  }, {
    key: "_resolveNode",
    value: function _resolveNode(node, index) {
      var _this4 = this;

      node.id = "node-".concat(index);
      node.children = (node.children || []).map(function (child) {
        return _this4.getNode(child);
      });

      if (node.mesh !== undefined) {
        node.mesh = this.getMesh(node.mesh);
      }

      if (node.camera !== undefined) {
        node.camera = this.getCamera(node.camera);
      }

      if (node.skin !== undefined) {
        node.skin = this.getSkin(node.skin);
      }
    }
  }, {
    key: "_resolveSkin",
    value: function _resolveSkin(skin, index) {
      skin.id = "skin-".concat(index);
      skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);
    }
  }, {
    key: "_resolveMesh",
    value: function _resolveMesh(mesh, index) {
      mesh.id = "mesh-".concat(index);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = mesh.primitives[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var primitive = _step2.value;

          for (var attribute in primitive.attributes) {
            primitive.attributes[attribute] = this.getAccessor(primitive.attributes[attribute]);
          }

          if (primitive.indices !== undefined) {
            primitive.indices = this.getAccessor(primitive.indices);
          }

          if (primitive.material !== undefined) {
            primitive.material = this.getMaterial(primitive.material);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "_resolveMaterial",
    value: function _resolveMaterial(material, index) {
      material.id = "material-".concat(index);

      if (material.normalTexture) {
        material.normalTexture.texture = this.getTexture(material.normalTexture.index);
      }

      if (material.occlusionTexture) {
        material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
      }

      if (material.emissiveTexture) {
        material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
      }

      if (material.pbrMetallicRoughness) {
        var mr = material.pbrMetallicRoughness;

        if (mr.baseColorTexture) {
          mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
        }

        if (mr.metallicRoughnessTexture) {
          mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
        }
      }
    }
  }, {
    key: "_resolveAccessor",
    value: function _resolveAccessor(accessor, index) {
      accessor.id = "accessor-".concat(index);
      accessor.bufferView = this.getBufferView(accessor.bufferView); // Look up enums

      accessor.bytesPerComponent = getBytesFromComponentType(accessor);
      accessor.components = getSizeFromAccessorType(accessor);
      accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;
    }
  }, {
    key: "_resolveTexture",
    value: function _resolveTexture(texture, index) {
      texture.id = "texture-".concat(index);
      texture.sampler = this.getSampler(texture.sampler);
      texture.source = this.getImage(texture.source);
    }
  }, {
    key: "_resolveSampler",
    value: function _resolveSampler(sampler, index) {
      sampler.id = "sampler-".concat(index); // Map textual parameters to GL parameter values

      sampler.parameters = {};

      for (var key in sampler) {
        var glEnum = this._enumSamplerParameter(key);

        if (glEnum !== undefined) {
          sampler.parameters[glEnum] = sampler[key];
        }
      }
    }
  }, {
    key: "_enumSamplerParameter",
    value: function _enumSamplerParameter(key) {
      return SAMPLER_PARAMETER_GLTF_TO_GL[key];
    }
  }, {
    key: "_resolveImage",
    value: function _resolveImage(image, index, options) {
      var _this5 = this;

      image.id = "image-".concat(index);

      if (image.bufferView !== undefined) {
        image.bufferView = this.getBufferView(image.bufferView);
      } // TODO - Handle non-binary-chunk images, data URIs, URLs etc
      // TODO - Image creation could be done on getImage instead of during load


      var _options$createImages = options.createImages,
          createImages = _options$createImages === void 0 ? true : _options$createImages;

      if (createImages) {
        image.image = this.glbParser.getImage(image);
      } else {
        image.getImageAsync = function () {
          return _this5.glbParser.getImageAsync(image);
        };
      }
    }
  }, {
    key: "_resolveBufferView",
    value: function _resolveBufferView(bufferView, index) {
      bufferView.id = "bufferView-".concat(index);
      bufferView.buffer = this.getBuffer(bufferView.buffer);

      if (this.glbParser) {
        bufferView.data = this.glbParser.getBufferView(bufferView);
      }
    }
  }, {
    key: "_decompressUberDracoPointCloud",
    value: function _decompressUberDracoPointCloud(primitive, extensions) {
      var bufferViewIndex = extensions.UBER_draco_point_cloud_compression.bufferView;
      var bufferView = this.getBufferView(bufferViewIndex); // TODO: change to getArrayFromBufferView()

      var compressedData = this.glbParser.getBufferView(bufferView);
      var dracoDecoder = new this.DracoDecoder();
      var decodedPrimitive = dracoDecoder.decode(compressedData); // TODO: what to do about original attributes

      primitive.attributes = decodedPrimitive.attributes; // TODO: stashing header on primitive, not sure if necessary

      primitive.header = decodedPrimitive.header; // TODO: drawmode is currently undefined, look into dracodecoder to set to 0 for point cloud

      primitive.drawMode = decodedPrimitive.drawMode || 0;
    } // PREPROC

  }, {
    key: "_resolveCamera",
    value: function _resolveCamera(camera) {
      // TODO - create 4x4 matrices
      if (camera.perspective) {// camera.matrix = createPerspectiveMatrix(camera.perspective);
      }

      if (camera.orthographic) {// camera.matrix = createOrthographicMatrix(camera.orthographic);
      }
    }
  }]);

  return GLTFParser;
}();

export { GLTFParser as default };
//# sourceMappingURL=gltf-parser.js.map