"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// This code is based on example code from the DRACO repository
// Copyright 2017 The Draco Authors.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
var draco3d = require('draco3d');

var DEFAULT_ENCODING_OPTIONS = {
  method: 'MESH_EDGEBREAKER_ENCODING',
  speed: [5, 5],
  quantization: {
    POSITION: 10
  }
};

function noop() {} // Copy encoded data to buffer


function dracoInt8ArrayToArrayBuffer(dracoData) {
  var byteLength = dracoData.size();
  var outputBuffer = new ArrayBuffer(byteLength);
  var outputData = new Int8Array(outputBuffer);

  for (var i = 0; i < byteLength; ++i) {
    outputData[i] = dracoData.GetValue(i);
  }

  return outputBuffer;
}
/* Encoder API:
https://github.com/google/draco/blob/master/src/draco/javascript/emscripten/draco_web_encoder.idl
   Example:
https://github.com/google/draco/blob/master/javascript/npm/draco3d/draco_nodejs_example.js
 */


var DRACOEncoder =
/*#__PURE__*/
function () {
  function DRACOEncoder() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DRACOEncoder);

    this.dracoEncoderModule = draco3d.createEncoderModule({});
    this.dracoEncoder = new this.dracoEncoderModule.Encoder();
    this.dracoMeshBuilder = new this.dracoEncoderModule.MeshBuilder();
    this.setOptions(Object.assign({}, DEFAULT_ENCODING_OPTIONS, opts));
    this.log = opts.log || noop;
  }

  _createClass(DRACOEncoder, [{
    key: "destroy",
    value: function destroy() {
      this.destroyEncodedObject(this.dracoMeshBuilder);
      this.destroyEncodedObject(this.dracoEncoder);
      this.dracoMeshBuilder = null;
      this.dracoEncoder = null;
      this.dracoEncoderModule = null;
    }
  }, {
    key: "destroyEncodedObject",
    value: function destroyEncodedObject(object) {
      if (object) {
        this.dracoEncoderModule.destroy(object);
      }
    } // Set encoding options.

  }, {
    key: "setOptions",
    value: function setOptions() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if ('speed' in opts) {
        var _this$dracoEncoder;

        (_this$dracoEncoder = this.dracoEncoder).SetSpeedOptions.apply(_this$dracoEncoder, _toConsumableArray(opts.speed));
      }

      if ('method' in opts) {
        var dracoMethod = this.dracoEncoderModule[opts.method]; // if (dracoMethod === undefined) {}

        this.dracoEncoder.SetEncodingMethod(dracoMethod);
      }

      if ('quantization' in opts) {
        for (var attribute in opts.quantization) {
          var bits = opts.quantization[attribute];
          var dracoPosition = this.dracoEncoderModule[attribute];
          this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);
        }
      }
    }
  }, {
    key: "encodePointCloud",
    value: function encodePointCloud(attributes) {
      // Build a `DracoPointCloud` from the input data
      var dracoPointCloud = this._createDracoPointCloud(attributes);

      var dracoData = new this.dracoEncoderModule.DracoInt8Array();

      try {
        var encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(dracoPointCloud, false, dracoData);

        if (!(encodedLen > 0)) {
          throw new Error('Draco encoding failed.');
        }

        this.log("DRACO encoded ".concat(dracoPointCloud.num_points(), " points\n        with ").concat(dracoPointCloud.num_attributes(), " attributes into ").concat(encodedLen, " bytes"));
        return dracoInt8ArrayToArrayBuffer(dracoData);
      } finally {
        this.destroyEncodedObject(dracoData);
        this.destroyEncodedObject(dracoPointCloud);
      }
    }
  }, {
    key: "encodeMesh",
    value: function encodeMesh(attributes) {
      // Build a `DracoMesh` from the input data
      var dracoMesh = this._createDracoMesh(attributes);

      var dracoData = new this.dracoEncoderModule.DracoInt8Array();

      try {
        var encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);

        if (encodedLen <= 0) {
          throw new Error('Draco encoding failed.');
        }

        this.log("DRACO encoded ".concat(dracoMesh.num_points(), " points\n        with ").concat(dracoMesh.num_attributes(), " attributes into ").concat(encodedLen, " bytes"));
        return dracoInt8ArrayToArrayBuffer(dracoData);
      } finally {
        this.destroyEncodedObject(dracoData);
        this.destroyEncodedObject(dracoMesh);
      }
    }
  }, {
    key: "_createDracoMesh",
    value: function _createDracoMesh(attributes) {
      var dracoMesh = new this.dracoEncoderModule.Mesh();

      try {
        var positions = this._getPositionAttribute(attributes);

        if (!positions) {
          throw new Error('positions');
        }

        var vertexCount = positions.length / 3;

        for (var attributeName in attributes) {
          var attribute = attributes[attributeName];

          this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);
        }
      } catch (error) {
        this.destroyEncodedObject(dracoMesh);
        throw error;
      }

      return dracoMesh;
    }
  }, {
    key: "_createDracoPointCloud",
    value: function _createDracoPointCloud(attributes) {
      var dracoPointCloud = new this.dracoEncoderModule.PointCloud();

      try {
        var positions = this._getPositionAttribute(attributes);

        if (!positions) {
          throw new Error('positions');
        }

        var vertexCount = positions.length / 3;

        for (var attributeName in attributes) {
          var attribute = attributes[attributeName];

          this._addAttributeToMesh(dracoPointCloud, attributeName, attribute, vertexCount);
        }
      } catch (error) {
        this.destroyEncodedObject(dracoPointCloud);
        throw error;
      }

      return dracoPointCloud;
    }
  }, {
    key: "_addAttributeToMesh",
    value: function _addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount) {
      if (!ArrayBuffer.isView(attribute)) {
        return;
      }

      var dracoAttributeType = this._getDracoAttributeType(attributeName, attribute);

      var size = attribute.length / vertexCount;

      if (dracoAttributeType === 'indices') {
        var numFaces = attribute.length / 3;
        this.log("Adding attribute ".concat(attributeName, ", size ").concat(numFaces));
        this.dracoMeshBuilder.AddFacesToMesh(dracoMesh, numFaces, attribute);
        return;
      }

      this.log("Adding attribute ".concat(attributeName, ", size ").concat(size));

      switch (attribute.constructor.name) {
        case 'Int8Array':
          this.dracoMeshBuilder.AddInt8Attribute(dracoMesh, dracoAttributeType, vertexCount, size, attribute);
          break;

        case 'Int16Array':
          this.dracoMeshBuilder.AddInt16Attribute(dracoMesh, dracoAttributeType, vertexCount, size, attribute);
          break;

        case 'Int32Array':
          this.dracoMeshBuilder.AddInt32Attribute(dracoMesh, dracoAttributeType, vertexCount, size, attribute);
          break;

        case 'Uint8Array':
        case 'Uint8ClampedArray':
          this.dracoMeshBuilder.AddUInt8Attribute(dracoMesh, dracoAttributeType, vertexCount, size, attribute);
          break;

        case 'Uint16Array':
          this.dracoMeshBuilder.AddUInt16Attribute(dracoMesh, dracoAttributeType, vertexCount, size, attribute);
          break;

        case 'Uint32Array':
          this.dracoMeshBuilder.AddUInt32Attribute(dracoMesh, dracoAttributeType, vertexCount, size, attribute);
          break;

        case 'Float32Array':
        default:
          this.dracoMeshBuilder.AddFloatAttribute(dracoMesh, dracoAttributeType, vertexCount, size, attribute);
      }
    } // DRACO can compress attributes of know type better
    // TODO - expose an attribute type map?

  }, {
    key: "_getDracoAttributeType",
    value: function _getDracoAttributeType(attributeName, attribute) {
      switch (attributeName.toLowerCase()) {
        case 'indices':
          return 'indices';

        case 'position':
        case 'positions':
        case 'vertices':
          return this.dracoEncoderModule.POSITION;

        case 'normal':
        case 'normals':
          return this.dracoEncoderModule.NORMAL;

        case 'color':
        case 'colors':
          return this.dracoEncoderModule.COLOR;

        case 'texCoord':
        case 'texCoords':
          return this.dracoEncoderModule.TEX_COORD;

        default:
          return this.dracoEncoderModule.GENERIC;
      }
    }
  }, {
    key: "_getPositionAttribute",
    value: function _getPositionAttribute(attributes) {
      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        var dracoType = this._getDracoAttributeType(attributeName, attribute);

        if (dracoType === this.dracoEncoderModule.POSITION) {
          return attribute;
        }
      }

      return null;
    }
  }]);

  return DRACOEncoder;
}();

exports.default = DRACOEncoder;
//# sourceMappingURL=draco-encoder.js.map