function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2019 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { CATEGORY } from './constant';
import XVIZBaseBuilder from './xviz-base-builder';
/**
 * XVIZTimeSeriesBuilder manages time_series data by `time` and `id` and stores
 * the the array of single stream value entries.
 *
 * This is the shape returned from getData()
 *
 * [
 *   {
 *     timestamp: x,
 *     streams: ['a', 'b'],
 *     values: {doubles: [1, 2]},
 *     object_id: '123'
 *   },
 *   {
 *     timestamp: y,
 *     streams: ['a', 'b'],
 *     values: {doubles: [1, 2]},
 *   }
 * ]
 */

export default class XVIZTimeSeriesBuilder extends XVIZBaseBuilder {
  constructor(props) {
    super(_objectSpread({}, props, {
      category: CATEGORY.time_series
    })); // Stores time_series data by timestamp then id
    // They will then be group when constructing final object

    this._data = new Map(); // inflight builder data

    this._id = null;
    this._value = null;
    this._timestamp = null;
  }

  id(identifier) {
    this.validatePropSetOnce('_id');
    this._id = identifier;
    return this;
  }

  value(value) {
    this.validatePropSetOnce('_value');

    if (value instanceof Array) {
      this.validateError('Input `value` must be single value');
    }

    this._value = value;
    return this;
  }

  timestamp(timestamp) {
    this.validatePropSetOnce('_timestamp');

    if (timestamp instanceof Array) {
      this.validateError('Input `timestamp` must be a single value');
    }

    this._timestamp = timestamp;
    return this;
  }

  getData() {
    this._flush();

    if (this._data.size === 0) {
      return null;
    }

    const timeSeriesData = [];

    for (const _ref of this._data) {
      var _ref2 = _slicedToArray(_ref, 2);

      const timestamp = _ref2[0];
      const ids = _ref2[1];

      for (const _ref3 of ids) {
        var _ref4 = _slicedToArray(_ref3, 2);

        const id = _ref4[0];
        const fields = _ref4[1];

        for (const tsdata of fields.values()) {
          const entry = {
            timestamp,
            streams: tsdata.streams,
            values: tsdata.values
          };
          /* eslint-disable camelcase, max-depth */

          if (id !== null) {
            entry.object_id = id;
          }
          /* eslint-enable camelcase, max-depth */


          timeSeriesData.push(entry);
        }
      }
    }

    return timeSeriesData;
  } // Lookup by timestamp, then id to store [streamId, value]


  _addTimestampEntry() {
    // this._data structure
    // timestamp: {
    //   id: {
    //     fieldName: {
    //       streams: []
    //       values: []
    //     }
    //   }
    // }
    if (!this._dataPending()) {
      return;
    } // Lookup where to put the value


    let fieldName = 'doubles';

    if (typeof this._value === 'string' || this._value instanceof String) {
      fieldName = 'strings';
    } else if (typeof this._value === 'boolean') {
      fieldName = 'bools';
    } // Building up the [(stream, value)] list


    let tsEntry = this._data.get(this._timestamp);

    if (tsEntry) {
      // We have timestamp, now get id
      const idEntry = tsEntry.get(this._id);

      if (idEntry) {
        const fieldEntry = idEntry.get(fieldName);

        if (fieldEntry) {
          // append entry to existing array
          fieldEntry.streams.push(this._streamId);
          fieldEntry.values[fieldName].push(this._value);
        } else {
          idEntry.set(fieldName, this._getFieldEntry(fieldName));
        }
      } else {
        // create new mapping of id -> array of entries
        tsEntry.set(this._id, this._getIdEntry(fieldName));
      }
    } else {
      // No timestamp entry
      // create new id -> array of entries
      // for same id different with fieldNames, we store as different ts entries
      tsEntry = new Map();
      tsEntry.set(this._id, this._getIdEntry(fieldName));

      this._data.set(this._timestamp, tsEntry);
    }
  }

  _getIdEntry(fieldName) {
    const idEntry = new Map();
    idEntry.set(fieldName, this._getFieldEntry(fieldName));
    return idEntry;
  }

  _getFieldEntry(fieldName) {
    return {
      streams: [this._streamId],
      values: {
        [fieldName]: [this._value]
      }
    };
  }

  _dataPending() {
    return this._value !== null || this._timestamp !== null || this._id !== null;
  }

  _validate() {
    if (this._dataPending()) {
      super._validate();

      if (this._value === null) {
        this.validateWarn(`Stream ${this._streamId} value is not provided.`);
      }

      if (this._timestamp === null) {
        this.validateWarn(`Stream ${this._streamId} timestamp is not provided.`);
      }
    }
  }

  _flush() {
    this._validate();

    this._addTimestampEntry();

    this._reset();
  } // reset the inflight values


  _reset() {
    this._id = null;
    this._value = null;
    this._timestamp = null;
  }

}
//# sourceMappingURL=xviz-time-series-builder.js.map