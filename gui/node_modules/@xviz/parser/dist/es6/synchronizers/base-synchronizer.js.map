{"version":3,"sources":["../../../src/synchronizers/base-synchronizer.js"],"names":["getXVIZConfig","xvizStats","LogSlice","memoize","assert","getCurrentLogSliceMemoized","streamFilter","lookAheadMs","bump","streamsByReverseTime","getCurrentFrameMemoized","logSlice","vehiclePose","trackedObjectId","postProcessFrame","getCurrentFrame","BaseSynchronizer","constructor","opts","time","loResTime","getLogSlice","PRIMARY_POSE_STREAM","getStream","_lastVehiclePose","getTime","getLoResTime","setTime","PLAYBACK_FRAME_RATE","Math","round","Number","isFinite","setLookAheadTimeOffset","offset","_empty","TIME_WINDOW","_lastLoResTime","_streamsByReverseTime","_getTimeRangeInReverse","empty","startTime","endTime"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {getXVIZConfig} from '../config/xviz-config';\nimport xvizStats from '../utils/stats';\nimport LogSlice from './log-slice';\n\nimport memoize from '../utils/memoize';\nimport assert from '../utils/assert';\n\n// MEMOIZATION OF LOGSLICE CONSTRUCTOR AND GET METHOD\nconst getCurrentLogSliceMemoized = memoize((streamFilter, lookAheadMs, ...streamsByReverseTime) => {\n  xvizStats.bump('getCurrentLogSliceMemoized');\n  return new LogSlice(streamFilter, lookAheadMs, streamsByReverseTime);\n});\n\nconst getCurrentFrameMemoized = memoize(\n  (logSlice, vehiclePose, trackedObjectId, postProcessFrame) => {\n    return logSlice.getCurrentFrame({vehiclePose, trackedObjectId}, postProcessFrame);\n  }\n);\n\n/**\n * Synchronizes log data across streams and provide the latest data\n * \"closest\" to a given timestamp within a time window.\n *\n * NOTES:\n * - logs typically use GPS time (no leap seconds)\n *   - Definition: http://www.leapsecond.com/java/gpsclock.htm\n *   - Web conversion: https://www.andrews.edu/~tzs/timeconv/timeconvert.php\n *   - Javascript conversion: https://www.npmjs.com/package/gps-time\n * - should vehicle_pose be selected based on time closes to the set time?\n *   It remains unclear what stream data is derived from which vehicle_pose\n *   due to the propogation of data thru the system.\n *\n * @param {Object[]} slices - Array of timeslices\n * - Each timeslice object must contain a GPS timestamp\n */\nexport default class BaseSynchronizer {\n  constructor(opts = {}) {\n    this.opts = opts;\n\n    this.time = 0;\n    this.loResTime = 0;\n    this.lookAheadMs = 0;\n  }\n\n  // The \"frame\" contains the processed and combined data from the current log slice\n  getCurrentFrame(streamFilter, trackedObjectId) {\n    xvizStats.bump('getCurrentFrame');\n\n    const logSlice = this.getLogSlice(streamFilter);\n    if (!logSlice) {\n      return null;\n    }\n\n    const {PRIMARY_POSE_STREAM} = getXVIZConfig();\n    const vehiclePose = logSlice.getStream(PRIMARY_POSE_STREAM, null);\n\n    if (vehiclePose !== this._lastVehiclePose) {\n      xvizStats.bump('vehiclePose');\n      this._lastVehiclePose = vehiclePose;\n    }\n\n    return getCurrentFrameMemoized(\n      logSlice,\n      vehiclePose,\n      trackedObjectId,\n      this.opts.postProcessFrame\n    );\n  }\n\n  // @return {Number} Currently set time\n  getTime() {\n    return this.time;\n  }\n\n  // The low resolution time is rounded to bigger intervals, throttling updates\n  getLoResTime() {\n    return this.loResTime;\n  }\n\n  /**\n   * @param {Number} time - time to synchronize the logs with\n   * @return {StreamSynchronizer} - returns itself for chaining.\n   */\n  setTime(time) {\n    const {PLAYBACK_FRAME_RATE} = getXVIZConfig();\n    this.time = time;\n    this.loResTime = Math.round(time * PLAYBACK_FRAME_RATE) / PLAYBACK_FRAME_RATE;\n    assert(Number.isFinite(this.time), 'Invalid time');\n    return this;\n  }\n\n  /**\n   * Set the lookAhead time offset.\n   *\n   * @param {Number} offset - milliseconds into the future\n   * @return {LogSynchronizer} - returns itself for chaining\n   */\n  setLookAheadTimeOffset(offset) {\n    // Change the offset time into an index.\n    this.lookAheadMs = offset;\n    return this;\n  }\n\n  // HELPER METHODS\n\n  // Get data for current time...\n  // @return {Object} - keys are stream names\n  //  values are the datum from each stream that best matches the current time.\n  getLogSlice(streamFilter) {\n    if (this._empty()) {\n      return null;\n    }\n\n    // Find the right timeslices\n    const {TIME_WINDOW} = getXVIZConfig();\n    this._lastLoResTime = this.loResTime;\n    this._streamsByReverseTime = this._getTimeRangeInReverse(\n      this.loResTime - TIME_WINDOW,\n      this.loResTime\n    );\n    xvizStats.bump('geometry-refresh');\n\n    return getCurrentLogSliceMemoized(\n      streamFilter,\n      this.lookAheadMs,\n      ...this._streamsByReverseTime\n    );\n  }\n\n  // PROTECTED API - DEFINED BY DERIVED CLASES\n\n  empty() {\n    assert(false);\n  }\n\n  /**\n   * Find and process stream data in the range (start, end] for process\n   * Returns a list of streams sorted by descending time\n   * Since we have all samples and can find the exact datum for the stream i\n   * there is no \"range\" of samples to process and the reverse ordering does not apply.\n   * @param Number startTime - The time to start from.\n   * @param Number endTime - The time to end at.\n   */\n  _getTimeRangeInReverse(startTime, endTime) {\n    assert(false);\n  }\n}\n"],"file":"base-synchronizer.js"}