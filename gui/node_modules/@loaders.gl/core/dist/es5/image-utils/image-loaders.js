"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PlatformImageLoader = exports.HTMLImageLoader = exports.ImageBitmapLoader = void 0;

/* global Image, Blob, createImageBitmap */
// Specifically loads an ImageBitmap (works on newer browser main and worker threads)
var ImageBitmapLoader = {
  parse: parseToImageBitmap
}; // Specifically loads an HTMLImage (works on alls browser main threads but not on worker threads)

exports.ImageBitmapLoader = ImageBitmapLoader;
var HTMLImageLoader = {
  load: loadToHTMLImage
}; // Loads a platform-specific image type that can be used as input data to WebGL textures

exports.HTMLImageLoader = HTMLImageLoader;
var PlatformImageLoader = {
  parse: parseToPlatformImage,
  load: loadToPlatformImage
}; // TODO - export functions that work on "platform images",
// e.g. extracts image data as typed array from any of the platform image formats.
// Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data

exports.PlatformImageLoader = PlatformImageLoader;

function parseToImageBitmap(arrayBuffer) {
  var blob = new Blob([new Uint8Array(arrayBuffer)]);
  return createImageBitmap(blob);
}

function loadToHTMLImage(url, options) {
  return new Promise(function (resolve, reject) {
    try {
      var image = new Image();

      image.onload = function () {
        return resolve(image);
      };

      image.onerror = function () {
        return reject(new Error("Could not load image ".concat(url, ".")));
      };

      image.crossOrigin = options && options.crossOrigin || 'anonymous';
      image.src = url;
    } catch (error) {
      reject(error);
    }
  });
}

function parseToPlatformImage(arrayBuffer) {
  if (typeof createImageBitmap === 'undefined') {
    return null;
  }

  return parseToImageBitmap(arrayBuffer);
}

function loadToPlatformImage(url, options) {
  return loadToHTMLImage(url, options);
}
//# sourceMappingURL=image-loaders.js.map