{"version":3,"sources":["../../../src/parsers/parse-stream-video-message.js"],"names":["LOG_STREAM_MESSAGE","TextDecoder","blobToArrayBuffer","parseLogMetadata","parseStreamVideoMessage","message","onResult","onError","Blob","then","arrayBuffer","catch","data","JSON","parse","result","parseStreamVideoData","error","ArrayBuffer","parseVideoFrame","type","parseVideoMetadata","ERROR","VIDEO_METADATA","view","DataView","VIDEO_FRAME","littleEndian","utf8Decoder","offset","version","getUint32","versionFlags","streamLength","stringStart","stream","decode","slice","timestamp","getFloat64","imageSize","imageData","imageType"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * This file contains parsers for XVIZ video stream protocol.\n * Naming conventions:\n * `message` refers to the raw message received via webSocket.onmessage\n * `data` refers to pre-processed data objects (blob, arraybuffer, JSON object)\n */\n/* global Blob */\nimport {LOG_STREAM_MESSAGE} from '../constants';\nimport {TextDecoder} from '../utils/text-encoding';\nimport {blobToArrayBuffer} from '../utils/binary';\n\nimport {parseLogMetadata} from './parse-log-metadata';\n\n// Handle messages from the stand alone video server\nexport function parseStreamVideoMessage(message, onResult, onError) {\n  if (message instanceof Blob) {\n    blobToArrayBuffer(message)\n      .then(arrayBuffer => {\n        parseStreamVideoMessage(arrayBuffer, onResult, onError);\n      })\n      .catch(onError);\n    return;\n  }\n\n  try {\n    let data = message;\n    if (typeof message === 'string') {\n      data = JSON.parse(message);\n    }\n    const result = parseStreamVideoData(data);\n    onResult(result);\n  } catch (error) {\n    onError(error);\n  }\n}\n\n// Handle messages from the stand alone video server\nexport function parseStreamVideoData(data) {\n  if (data instanceof ArrayBuffer) {\n    return parseVideoFrame(data);\n  }\n  if (data.type === 'metadata') {\n    return parseVideoMetadata(data);\n  }\n  // Unknown message\n  return {type: LOG_STREAM_MESSAGE.ERROR, message: 'Unknown stream data type', data};\n}\n\n// Extract metadata from stream message\nfunction parseVideoMetadata(data) {\n  const result = parseLogMetadata(data);\n  result.type = LOG_STREAM_MESSAGE.VIDEO_METADATA;\n\n  return result;\n}\n\n// Parse image data from stream message\n// https://code.int.uberatc.com/diffusion/AV/browse/master/source/xviz/services/video/www/index.js\nexport function parseVideoFrame(arrayBuffer) {\n  const view = new DataView(arrayBuffer);\n\n  // Read off version\n  const result = {type: LOG_STREAM_MESSAGE.VIDEO_FRAME};\n  const littleEndian = true;\n  const utf8Decoder = new TextDecoder('utf-8');\n\n  // Check version\n  let offset = 0;\n  result.version = view.getUint32(offset, littleEndian);\n  offset += 4;\n  result.versionFlags = view.getUint32(offset, littleEndian);\n  offset += 4;\n\n  // Read off stream name\n  const streamLength = view.getUint32(offset, littleEndian);\n  const stringStart = offset + 4;\n  offset += 4 + streamLength;\n\n  result.stream = utf8Decoder.decode(arrayBuffer.slice(stringStart, offset));\n\n  // Read off timestamp\n  result.timestamp = view.getFloat64(offset, littleEndian);\n  offset += 8;\n\n  // Read slice off the image data\n  const imageSize = view.getUint32(offset, littleEndian);\n  offset += 4;\n\n  result.imageData = arrayBuffer.slice(offset, offset + imageSize);\n  result.imageType = 'image/jpeg';\n\n  return result;\n}\n"],"file":"parse-stream-video-message.js"}